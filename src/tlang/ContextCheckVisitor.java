package tlang;

import java.util.Map;
import java.util.Optional;
import org.antlr.v4.runtime.ParserRuleContext;
import org.antlr.v4.runtime.RuleContext;
import org.antlr.v4.runtime.Token;
import org.antlr.v4.runtime.tree.ParseTree;
import org.antlr.v4.runtime.tree.TerminalNode;
import tlang.Scope.VarInfo;
import static tlang.TLantlrParser.*;
import static tlang.TUtil.*;

/** Visitor for syntactical context checking of parsed T programs, sometimes
 * called a "semantic check". Operates on a syntax oriented parse
 * tree generated by Antlr.
 *
 * All the work is done in the constructor. ContextCheckVisitor performs an initial pass using
 * FieldVisitor.
 *
 *
 *
 * @author George S. Cowan
 */
@SuppressWarnings("javadoc")
public class ContextCheckVisitor extends TLantlrBaseVisitor<Void> {

private static final String reservedCharString = "$T$";
private static final String invalidCharsMsg
      = reservedCharString +" is reserved for T language internal use only";

/** Is Context in code with statements, i.e., method, constructor, or
 * initializer, but not field initialization
 */
private boolean isInExecutable = false;

/** Is Context in non-executable logic statement, e.g., constraint or means,
 *  but not conjecture
 */
private boolean isInLogic = false;

/** Is Context in the construction of a name of a variable or value for
 * assignment, i.e., assignable (LHS) or method parameter
 */
private boolean isInAssignment = false;

private static final String program = "Context Check";
Map<RuleContext, Scope> scopeMap;
public Map<RuleContext, tlang.Scope> getScopeMap() { return scopeMap; }

CollectingMsgListener errs;
Scope currentScope = null;

private String packageName = ""; // in case there is no package
  public String getPackageName() { return packageName; }

private String topTypeName = ""; // "" means thisIsTheTopLevelType()
  public String getTopTypeName() { return topTypeName; }
  private boolean thisIsTheTopLevelType() { return topTypeName.equals(""); }


public ContextCheckVisitor( ParseTree tree
                          , CollectingMsgListener msgListener
                          , Map<RuleContext, Scope> scopeMap
                          ) {
  this.errs = msgListener;
  this.scopeMap = scopeMap;
  new FieldVisitor(program, errs, scopeMap).visit(tree);
}



public String getCompoundTypeName() {
  if (packageName.length() > 0 && topTypeName.length() > 0) {
    return packageName +"."+ topTypeName;
  } else {
    return topTypeName; // may be ""
  }
}

@Override public Void
visitT_packageDeclaration(T_packageDeclarationContext ctx) {
  packageName = ctx.t_qualifiedName().getText();
  // return visitChildren(ctx); // no changes to package, no need to visit
  return null;
}

@Override public Void
visitT_classDeclaration(T_classDeclarationContext ctx) {
  String className = checkedText(ctx.UndecoratedIdentifier());
  typeDeclarationVisit(className, ctx);
  return null;
}

@Override public Void
visitEnumDeclaration(EnumDeclarationContext ctx) {
  String enumName = ctx.Identifier().toString();
  typeDeclarationVisit(enumName, ctx);
  return null;
}

@Override public Void
visitT_interfaceDeclaration(T_interfaceDeclarationContext ctx) {
  String interfaceName = checkedText(ctx.UndecoratedIdentifier());
  typeDeclarationVisit(interfaceName, ctx);
  return null;
}

@Override public Void
visitAnnotationTypeDeclaration(AnnotationTypeDeclarationContext ctx) {
  String annotationName = ctx.Identifier().toString();
  if (thisIsTheTopLevelType()) { topTypeName = annotationName; }
  // Do not visitChildren(ctx); We make no changes to an AnnotationType
  return null;
}

  /**
   * Check for incorrectly decorated value name or a field name that has already been used. The
   * variable name, value name, and line number have already been collected into the varInto by the
   * {@link FieldVisitor}.
   * <p>{@inheritDoc}
   */
@Override public Void
visitInitializedField(InitializedFieldContext ctx) {
  final Token varOrValueNameToken = ctx.t_idDeclaration().getStart();
  final String varName = variableName(varOrValueNameToken.getText());
  VarInfo varInfo = currentScope.varToInfoMap.get(varName);
  checkForDecorationErrors(varOrValueNameToken);
  checkForAlreadyDeclared(varOrValueNameToken, varName, varInfo);
  return visitChildren(ctx);
}


  private void checkForDecorationErrors(final Token varOrValueNameToken) {
    if (isMidDecorated(varOrValueNameToken)) {
      collectMsgForMidDecoratedField(varOrValueNameToken);
    } else if (isUndecorated(varOrValueNameToken)) {
      collectMsgForUndecoratedField(varOrValueNameToken);
      defineValueToMakeFollowingMessagesMoreUseful(varOrValueNameToken);
    }
  }

  private void collectMsgForMidDecoratedField(final Token varOrValueNameToken) {
    final String msg = String.format
        ("Field declaration %s cannot be mid-decorated", varOrValueNameToken.getText());
    errs.collectError(program, varOrValueNameToken, msg);
  }

  private void collectMsgForUndecoratedField(final Token varOrValueNameToken) {
    final String msg = String.format
          ("Must use a decorated value name if the field %s is initialized"
          , varOrValueNameToken.getText()
          );
    errs.collectError(program, varOrValueNameToken, msg);
  }

  private void defineValueToMakeFollowingMessagesMoreUseful(final Token varOrValueNameToken) {
    String varOrValueName = varOrValueNameToken.getText();
    final String varName = variableName(varOrValueName);
    VarInfo varInfo = currentScope.varToInfoMap.get(varName);
    varInfo.defineNewValue("'"+ varName, varOrValueNameToken.getLine());
  }

/**
 * Check for an already declared variable with the same name. The variable name, value name, and
 * line number have already been collected into the varInto by the {@link FieldVisitor}.
 * <p>{@inheritDoc}
 */
@Override public Void
visitUninitializedField(UninitializedFieldContext ctx) {
  final Token varOrValueNameToken = ctx.t_idDeclaration().getStart();
  final String varName = variableName(varOrValueNameToken.getText());
  VarInfo varInfo = currentScope.varToInfoMap.get(varName);
  checkForAlreadyDeclared(varOrValueNameToken, varName, varInfo);
  return visitChildren(ctx);
}

private void
checkForAlreadyDeclared(Token varOrValueNameToken, String varName, VarInfo varInfo) {
  final int lineOfExistingVar = varInfo.getLineWhereDeclared();
  if (lineOfExistingVar != varOrValueNameToken.getLine()) {
    final String msg = String.format
        ("The field %s was already declared at line %d", varName, lineOfExistingVar);
    errs.collectError(program, varOrValueNameToken, msg);
  }
}

/**
 * {@inheritDoc}
 */
@Override public Void
visitT_methodDeclaration(T_methodDeclarationContext ctx) {
  final Token methodNameToken = ctx.UndecoratedIdentifier().getSymbol();
  final String methodId = idWithLC("method", methodNameToken.getText(), methodNameToken);
  executableVisit(methodId, ctx);
  return null;
}

/**
 * {@inheritDoc}
 */
@Override public Void
visitT_initializer(T_initializerContext ctx) {
  final String initializerId = idWithLC("initializer", ctx.getStart());
  executableVisit(initializerId, ctx);
  return null;
}

/**
 * {@inheritDoc}
 * <p/>
 * The default implementation returns the result of calling
 * {@link #visitChildren} on {@code ctx}.
 */
@Override public Void
visitT_constructorDeclaration(T_constructorDeclarationContext ctx) {
  final String constructorId = idWithLC("constructor", ctx.UndecoratedIdentifier().getSymbol());
  executableVisit(constructorId, ctx);
  return null;
}

/**
 * An identifier for a token constructed from the prependString, the line that the forToken is on,
 * and the position in the line for the first character of the forToken. For implementation reasons
 * the line number starts counting with one, but the character position in the line starts counting
 * with zero. Example: the identifier for the starting token of a block might be
 * <code>block-L24C4</code>.
 */
private String idWithLC(String prependString,Token forToken) {
  return idWithLC(prependString, "", forToken);
}

/**
 * An identifier for a token constructed from the prependString, the line that the forToken is on,
 * the position in the line for the first character of the forToken, and an appendString. For
 * implementation reasons the line number starts counting with one, but the character position in
 * the line starts counting with zero. Example: the identifier for a method might be
 * <code>method-L24C12-toString</code>.
 */
private String idWithLC(String prependString, String appendString, Token forToken) {
  int line = forToken.getLine();
  int charPosition = forToken.getCharPositionInLine();
  return prependString +"-L"+ line +"C"+ charPosition +"-"+  appendString;
}

/**
 * All executables have a background scope for a parent in order to hold all
 * the higher scope fields.
 * @param execType a unique name for the executable code of the context
 * @param executableContext
 */
private void executableVisit(String execType, ParserRuleContext executableContext) {
  final Scope grandParent = currentScope;
  BackgroundScope background = new BackgroundScope(program, "background-"+ execType, grandParent);
  currentScope  = new Scope(program, execType, background);
  scopeMap.put(executableContext, currentScope);
  final boolean oldInExecutable = isInExecutable;
  isInExecutable = true;

  visitChildren(executableContext);

  isInExecutable = oldInExecutable;
  //keep scope variable info for code generation
  currentScope.clearForCodeGen();
  background.clearForCodeGen(); // clean the background
  currentScope = grandParent; //pop
}


/**
 * {@inheritDoc}
 */
@Override public Void
visitT_block(T_blockContext ctx) {
  final Token firstToken = ctx.getStart();
  final int startingChar = firstToken.getCharPositionInLine();
  String blockLabel = "block_L"+ firstToken.getLine() +"C"+ startingChar;
  final Scope parent = currentScope;
  currentScope  = new Scope(program, blockLabel, parent);
  scopeMap.put(ctx, currentScope);

  visitChildren(ctx);

  currentScope.clearForCodeGen();
  currentScope = parent;
  return null;
}

/**
 * {@inheritDoc}
 */
@Override public Void
visitAssignStmt(AssignStmtContext ctx) {
  // we reverse the sequential order of visiting the children
  // in order to reflect the idea that the assignment happens after the
  // expression is evaluated. This has concrete effect in the fact that
  // we don't want the current value changed until the end of the assignment.
  visit(ctx.t_expression());
  visit(ctx.t_assignable());
  return null;
}


/**
 * {@inheritDoc}
 */
@Override public Void
visitT_assignable(T_assignableContext ctx) {
  final boolean oldInAssignment = isInAssignment;
  isInAssignment = true;

  visitChildren(ctx);

  isInAssignment = oldInAssignment;
  return null;
}

/**
 * {@inheritDoc}
 */
@Override public Void
visitT_initializedVariableDeclaratorId(T_initializedVariableDeclaratorIdContext ctx) {
  final T_idDeclarationContext declCtx = ctx.t_idDeclaration();
  final Token valueNameToken = declCtx.getStart();
  String valueName = valueNameToken.getText();
  if (isMidDecorated(valueNameToken)) {
    errs.collectError(program, valueNameToken
        , "Variable declarations cannot be mid-decorated"
        );
  } else if (isUndecorated(valueNameToken)) {
    errs.collectError(program, valueNameToken
        , "Initialized variable declarations must be decorated"
        );
    // hoping to improve err msgs for following code:
    valueName = "'"+ valueName;
  }
  VarInfo newVarInfo = currentScope.declareVarName(valueNameToken, declCtx.idType);
  final boolean varAlreadyDeclared = (newVarInfo == null);
  if (varAlreadyDeclared) {
    String varName = variableName(valueName );
    VarInfo existingVarInfo = currentScope.getConflictingVarDeclarationInfo(varName);
    final String msg = String.format
      ("Attempted to declare variable %s, but it was already declared at line %d"
      , varName, existingVarInfo.getLineWhereDeclared()
      );
    errs.collectError(program, valueNameToken, msg);
    // perhaps defining this as a value for the existing variable will help clean up error msgs in
    // following code
    existingVarInfo.defineNewValue(valueName, valueNameToken.getLine());
  }
  return null;
}

/**
 * {@inheritDoc}
 */
@Override public Void
visitT_uninitializedVariableDeclaratorId(T_uninitializedVariableDeclaratorIdContext ctx) {
  final T_idDeclarationContext declCtx = ctx.t_idDeclaration();
  final Token varNameToken = declCtx.getStart();
  if (isDecorated(varNameToken)) {
    errs.collectError(program, varNameToken
                   , "A variable declaration may not be decorated unless it is initialized"
                   );
  }
  currentScope.declareVarName(varNameToken, declCtx.idType);
  return null;
}

/**
 * {@inheritDoc}
 */
@Override public Void
visitT_means(T_meansContext ctx) {
  final boolean oldInLogic = isInLogic;
  isInLogic = true;

  visitChildren(ctx);

  isInLogic = oldInLogic;
  return null;
}

/**
 * {@inheritDoc}
 */
@Override public Void
visitT_expression(T_expressionContext ctx) {
  final boolean oldInAssignment = isInAssignment;
  isInAssignment = false;

  visitChildren(ctx);

  isInAssignment = oldInAssignment;
  return null;
}

/**
 * {@inheritDoc}
 */
@Override public Void
visitT_identifier(T_identifierContext ctx) {
  if (currentScope != null) { // i.e., we are inside a type definition
    if (isInExecutable) {
      if ( isInAssignment) { checkAssignment(ctx); }
                      else { checkReference(ctx);  }
    }
  }
  final Token idToken = ctx.start;
    // There is a single token and we don't need to know which identifier type
    // it is: pre-, mid-, or post-decorated, or undecorated
  checkForReservedChars(idToken);

  return null;
}

///**
// * {@inheritDoc}
// *
// * <p>The default implementation returns the result of calling
// * {@link #visitChildren} on {@code ctx}.</p>
// * @return
// */
//@Override public Void
//visitT_undecoratedIdentifier(T_undecoratedIdentifierContext ctx) {
//  final Token idToken = ctx.start;
//  String id = idToken.getText();
//  if (id.contains(reservedCharString)) {
//    errs.collectError( program, idToken , invalidCharsMsg);
//  }
//  return doNotVisitChildren;
//  }

//@Override public Void
//visitT_invalidIdentifierWithReservedString(T_invalidIdentifierWithReservedStringContext ctx) {
//  final Token valueNameToken = ctx.getStart();
//  errs.collectError( program, valueNameToken , invalidCharsMsg);
//  return doNotVisitChildren;
//}



// *************** Helper methods *******************************

public void typeDeclarationVisit(String typeName, ParserRuleContext ctx) {
  // Assumption: field visitor has created a Scope object and loaded it
  // with class fields (and their value names if they were initialized) but it has not
  // filled in the parent scope for that Scope object except for the instance of the top level type.
  // We let the Java compiler check for a single visible top-level type per file.
  final Scope parent = currentScope;
  final Scope savedClassScopeFromFieldVisitor = scopeMap.get(ctx);

  if (thisIsTheTopLevelType()) { topTypeName = typeName; }
  if (savedClassScopeFromFieldVisitor == null) { //push new
    currentScope = new Scope(program, typeName, parent);
    scopeMap.put(ctx, currentScope);
  } else { //or push existing
    setParentIfInnerClass(savedClassScopeFromFieldVisitor, parent);
    currentScope = savedClassScopeFromFieldVisitor;
  }

  visitChildren(ctx);

  currentScope.clearForCodeGen();
  currentScope = parent; //pop
}
private void setParentIfInnerClass(Scope possibleInnerClass, Scope parent) {
  if (possibleInnerClass.parent == null) { // yes, it's an inner class
    possibleInnerClass.setParent(currentScope);
  }
}
private void checkAssignment(T_identifierContext ctx) {
  final Token valueNameToken = ctx.start;
  String valueName = valueNameToken.getText();
  final String varName = variableName(valueName);
  Optional<VarInfo> OptVar = currentScope.getOptionalExistingVarInfo(varName);
  if ( ! OptVar.isPresent()) { // variable not in scope
    final String msg =
        String.format("Variable %s has not been defined in this scope", varName);
    errs.collectError( program, valueNameToken, msg);
    // in hopes of generating better error msgs for the following code:
    currentScope.declareVarName(valueNameToken, "NoTypeForUndeclaredVariableAssignment$t$");
  } else { // we have valid variable information
    final VarInfo varInfo = OptVar.get();
    final String currentValueName = varInfo.getCurrentValueName();
    final boolean hasCurrentValue = (currentValueName != null);
    if (hasCurrentValue && isFinalDecorated(currentValueName)) {
      final String msg = String.format
          ("%s was final decorated at line %d so it cannot receive a new value"
          , varName, varInfo.lineOf(currentValueName)
          );
      errs.collectError( program, valueNameToken, msg);
    } else if (isUndecorated(valueNameToken)) {
      errs.collectError( program, valueNameToken
                     , varName +" is not a decorated value name so it cannot receive a value"
                     );
      // in hopes of generating better error msgs for following code we pretend
      // to start over with an initial value
      valueName = "'"+ varName;
    } else { // decorated value name
      Integer existingValueLineNum = varInfo.lineOf(valueName);
      final boolean valueAlreadyExists = (existingValueLineNum != null);
      if (valueAlreadyExists) {
        final String msg = String.format
          ("The value %s has already been defined on line %d"
          , valueName, existingValueLineNum
          );
        errs.collectError( program, valueNameToken, msg);
      }
    }
    // even if there were errors, we proceed
    // in hopes of generating better error msgs for the following code
    varInfo.defineNewValue(valueName, valueNameToken.getLine());
  }
}

private void checkReference(T_identifierContext ctx) {
  final Token valueNameToken = ctx.getStart();
  String valueName = valueNameToken.getText();
  final String varName = variableName(valueName);
  VarInfo varInfo = currentScope.getOptionalExistingVarInfo(varName).orElse(null);
  if ( varInfo == null) { // variable is not in scope
    final String msg = String.format("Variable %s has not been defined in this scope", varName);
    errs.collectError( program, valueNameToken , msg);
    varInfo = attemptRecoveryForMissingVariable(valueNameToken);
  } else { // var is in scope
    if ( ! valueName.equals(varInfo.getCurrentValueName())) {
      if (varInfo.hasDefinedValue(valueName)) {
        if (isInExecutable && ! isInLogic) {
          varInfo.reusedValueNames.add(valueName);
        }
      } else {
        errorAndRecoveryForReferenceToUndefinedValue(valueNameToken, varInfo);
      }
    }
  }
}

private void errorAndRecoveryForReferenceToUndefinedValue(Token valueNameToken, VarInfo varInfo) {
  String valueName = valueNameToken.getText();
  if (isDecorated(valueNameToken)) {
    final String msg = String.format("Value %s has not been defined", valueName);
    errs.collectError( program, valueNameToken, msg);
  } else {
    issueUndecoratedMsg(valueNameToken, valueName);
    // construct an arbitrary value name for better error msgs in the following code
    valueName = "'"+ valueName;
  }
  // create the value in hopes of generating better error msgs in following code
  varInfo.defineNewValue(valueName, valueNameToken.getLine());
}

/** We generate the missing VarInfo and make sure that it has some current value decoration, hoping
 * that this will result in generating better error messages in the following code.
 *  @return A dummy VarInfo
 */
private VarInfo attemptRecoveryForMissingVariable(Token valueNameToken) {
  VarInfo varInfo = currentScope.declareVarName(valueNameToken, "NoTypeForUndeclaredReference");
  if (isUndecorated(valueNameToken)) {
    final String valueName = valueNameToken.getText();
    issueUndecoratedMsg(valueNameToken, valueName);
    varInfo.defineNewValue("'"+ valueName, valueNameToken.getLine());
  }
  return varInfo;
}

private void issueUndecoratedMsg(Token valueNameToken, String valueName) {
  final String undecoratedMsg = String.format
      ( "A reference to a value must be a value name: %s must be decorated"
      , valueName
      );
  errs.collectError(program, valueNameToken, undecoratedMsg);
}

String checkedText(TerminalNode id) {
  checkForReservedChars(id.getSymbol());
  return id.getText();
}

private void checkForReservedChars(final Token idToken) {
  final String id = idToken.getText();
  if (id.contains(reservedCharString)) {
    errs.collectError(program, idToken , invalidCharsMsg);
  }
}

//TODO include rest of visit methods for value related code

} // end class FieldVisitor
