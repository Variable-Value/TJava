package tlang;

import java.util.Collections;
import java.util.HashSet;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import org.antlr.v4.runtime.ParserRuleContext;
import org.antlr.v4.runtime.RuleContext;
import org.antlr.v4.runtime.Token;
import org.antlr.v4.runtime.tree.ParseTree;
import org.antlr.v4.runtime.tree.TerminalNode;
import tlang.Scope.VarInfo;
import tlang.TLantlrParser.T_nestedBlockContext;
import static tlang.TLantlrParser.*;
import static tlang.TUtil.*;

/** Visitor for syntactical context checking of parsed T programs, sometimes
 * called a "semantic check". Operates on a syntax oriented parse
 * tree generated by Antlr.
 * <p>
 * All the work is done when the constructor is invoked. First the FieldVisitor is invoked, then
 * the context checking begins.
 */
public class ContextCheckVisitor extends TLantlrBaseVisitor<Void> {

private static final String reservedCharString = "$T$";
private static final String invalidCharsMsg
      = reservedCharString +" is reserved for T language internal use only";

/** Is Context in code with statements, i.e., method, constructor, or
 * initializer, but not field initialization
 */
private boolean isInExecutable = false;

/** Is Context in non-executable logic statement, e.g., constraint or means,
 *  but not conjecture
 */
private boolean isInLogic = false;

/** Are we in executable code nested within a conditional statement and in the first conditional
 * branch, e.g., then-block of an if-then-else? */
private boolean isInInitialBranch = false;

/** Are we in executable code nested within a conditional statement and in a conditional
 * branch that follows another branch, e.g., else- or else-if-block of an if-then-else? */
private boolean isInFollowingBranch = false;

/** Are we in conditional branch, as opposed to open code */
private boolean isInConditionalBranch() { return isInInitialBranch || isInFollowingBranch; }

private static final HashSet<String> EMPTY_HASH_SET = new HashSet<>(0);
private HashSet<String> nestedValueNames = EMPTY_HASH_SET;

/** Is Context in the construction of a name of a variable or value for
 * assignment, i.e., assignable (LHS) or method parameter
 */
private boolean isInAssignment = false;

private static final String program = "Context Check";
Map<RuleContext, Scope> scopeMap;
public Map<RuleContext, tlang.Scope> getScopeMap() { return scopeMap; }

CollectingMsgListener errs;
Scope currentScope = null;

//@formatter:off
private String packageName = ""; // in case there is no package
  public String getPackageName() { return packageName; }

private String topTypeName = ""; // "" means thisIsTheTopLevelType()
  public String getTopTypeName() { return topTypeName; }
  private boolean thisIsTheTopLevelType() { return topTypeName.equals(""); }

//@formatter:on

public ContextCheckVisitor(
  ParseTree tree,
  CollectingMsgListener msgListener,
  Map<RuleContext, Scope> scopeMap)
{
  this.errs = msgListener;
  this.scopeMap = scopeMap;
  new FieldVisitor(program, errs, scopeMap).visit(tree);
}


public String getCompoundTypeName() {
  if (packageName.length() > 0 && topTypeName.length() > 0) {
    return packageName +"."+ topTypeName;
  } else {
    return topTypeName; // may be ""
  }
}

@Override
public Void visitT_packageDeclaration(T_packageDeclarationContext ctx) {
  packageName = ctx.t_qualifiedName().getText();
  // return visitChildren(ctx); // no changes to package, no need to visit
  return null;
}

@Override
public Void visitT_classDeclaration(T_classDeclarationContext ctx) {
  String className = checkedText(ctx.UndecoratedIdentifier());
  typeDeclarationVisit(className, ctx);
  return null;
}

@Override
public Void visitEnumDeclaration(EnumDeclarationContext ctx) {
  String enumName = ctx.Identifier().toString();
  typeDeclarationVisit(enumName, ctx);
  return null;
}

@Override
public Void visitT_interfaceDeclaration(T_interfaceDeclarationContext ctx) {
  String interfaceName = checkedText(ctx.UndecoratedIdentifier());
  typeDeclarationVisit(interfaceName, ctx);
  return null;
}

@Override
public Void visitAnnotationTypeDeclaration(AnnotationTypeDeclarationContext ctx) {
  String annotationName = ctx.Identifier().toString();
  if (thisIsTheTopLevelType())
    topTypeName = annotationName;

  // Do not visitChildren(ctx); We make no changes to an AnnotationType
  return null;
}

/** Check the Condition, then-block, and any else block for errors as separate executables, and
 * check that any varNames defined in one of the executable blocks is also defined in the other.
 * <p>
 * A then block at the top level code statements needs to record the new value names assigned. Any
 * else block then needs a fresh copy of that list to make sure it assigns exactly the same value
 * names. The reason it needs a fresh copy is because it checks off the value names assigned by
 * deleting them from the list. Note that an else if clause also needs a fresh copy of the list. */
@Override
public Void visitIfStmt(IfStmtContext ctx) {
  visitChildren(ctx.t_parExpression());

  if (isInInitialBranch) { // if-statement is nested in initial branch

    cloneOf(nestedValueNames);
    //TODO: complete if nested in InitialBranch
    visitNestedBlock(ctx.t_nestedBlock(0), "then"); // adds assigned value names to stack as it processes rhs of assigns

  } else if (isInFollowingBranch) { // if-statement is nested in following branch

    // start with a fresh copy of the nestedValueNames Set so we can
    // see if new valueNames are in the set (and remove them)
    // then make sure none are left in the set

  } else { // if-statement is in top level code

    nestedValueNames = new HashSet<>();
    isInInitialBranch = true;
    visitNestedBlock(ctx.t_nestedBlock(0), "then");
    //TODO: current value must revert to pre-if current value
    isInInitialBranch = false;

    // we keep using the same nestedValueNames Set
    isInFollowingBranch = true;
    T_nestedBlockContext elseNestedBlockCtx = ctx.t_nestedBlock(1);
    if (elseNestedBlockCtx != null)
      visitNestedBlock(elseNestedBlockCtx, "else");
    isInFollowingBranch = false;

    for(String valueName : nestedValueNames) {
      String msg = valueName +" was not defined in the else-clause";
      errs.collectError(program, ctx.getStop(), msg);
    }
    nestedValueNames = EMPTY_HASH_SET;

  }

  // TODO but what if we are in the then branch of an if-then-else that is in a loop block under an else branch ???
  //      then we need a stack of sets of obligations recieved and a set of delegations given by the inital branch
  //      to ALL following branches. We need to copy all the enclosing conditionals for each following branch.
  //      We need to only track a valueName back to the level it was defined.
  //      Create the tests for this and implemetn one simple step at a time (Uncle Bob's transformations).

  return null;
}

private HashSet<String> cloneOf(HashSet<String> hashSet) {
  return (HashSet<String>)hashSet.clone();
}


private void visitNestedBlock(T_nestedBlockContext nestedBlockCtx, String idPrefix) {
  String clauseId = idWithLC(idPrefix, nestedBlockCtx.getStart());
  visitCodeScope(clauseId, nestedBlockCtx, currentScope);
}

@Override public Void visitT_nestedBlock(TLantlrParser.T_nestedBlockContext ctx) {

  visitChildren(ctx);

  return null;
  }

/** Check for incorrectly decorated value name or a field name that has already been used. The
 * variable name, value name, and line number have already been collected into the varInto by the
 * {@link FieldVisitor}.
 * <p>
 * {@inheritDoc} */
@Override
public Void visitInitializedField(InitializedFieldContext ctx) {
  final Token varOrValueNameToken = ctx.t_idDeclaration().getStart();
  final String varName = TUtil.variableName(varOrValueNameToken);
  VarInfo varInfo = currentScope.varToInfoMap.get(varName);
  checkForDecorationErrors(varOrValueNameToken);
  checkForAlreadyDeclared(varOrValueNameToken, varName, varInfo);
  return visitChildren(ctx);
}


  private void checkForDecorationErrors(final Token varOrValueNameToken) {
    if (isMidDecorated(varOrValueNameToken)) {
      collectMsgForMidDecoratedField(varOrValueNameToken);
    } else if (isUndecorated(varOrValueNameToken)) {
      collectMsgForUndecoratedField(varOrValueNameToken);
      defineValueToMakeFollowingMessagesMoreUseful(varOrValueNameToken);
    }
  }

  private void collectMsgForMidDecoratedField(final Token varOrValueNameToken) {
    final String msg = String.format
        ("Field declaration %s cannot be mid-decorated", varOrValueNameToken.getText());
    errs.collectError(program, varOrValueNameToken, msg);
  }

private void collectMsgForUndecoratedField(final Token varOrValueNameToken) {
  final String msg = String.format("Must use a decorated value name if the field %s is initialized",
                                   varOrValueNameToken.getText());
  errs.collectError(program, varOrValueNameToken, msg);
}

  private void defineValueToMakeFollowingMessagesMoreUseful(final Token varOrValueNameToken) {
    String varOrValueName = varOrValueNameToken.getText();
    final String varName = variableName(varOrValueName);
    VarInfo varInfo = currentScope.varToInfoMap.get(varName);
  varInfo.defineNewValue("'" + varName, varOrValueNameToken.getLine());
}

/**
 * Check for an already declared variable with the same name. The variable name, value name, and
 * line number have already been collected into the varInfo by the {@link FieldVisitor}.
 * <p>{@inheritDoc}
 */
@Override public Void visitUninitializedField(UninitializedFieldContext ctx) {
  final Token varOrValueNameToken = ctx.t_idDeclaration().getStart();
  final String varName = TUtil.variableName(varOrValueNameToken);
  VarInfo varInfo = currentScope.varToInfoMap.get(varName);
  checkForAlreadyDeclared(varOrValueNameToken, varName, varInfo);
  return visitChildren(ctx);
}

private void checkForAlreadyDeclared(Token varOrValueNameToken, String varName, VarInfo varInfo) {
  final int lineOfExistingVar = varInfo.getLineWhereDeclared();
  if (lineOfExistingVar != varOrValueNameToken.getLine()) {
    String template = "The field %s was already declared at line %d";
    String msg = String.format(template, varName, lineOfExistingVar);
    errs.collectError(program, varOrValueNameToken, msg);
  }
}

@Override
public Void visitT_methodDeclaration(T_methodDeclarationContext ctx) {
  final Token methodNameToken = ctx.UndecoratedIdentifier().getSymbol();
  final String methodId = idWithLC("method", methodNameToken.getText(), methodNameToken);
  executableVisit(methodId, ctx);
  return null;
}

@Override
public Void visitT_initializer(T_initializerContext ctx) {
  final String initializerId = idWithLC("initializer", ctx.getStart());
  executableVisit(initializerId, ctx);
  return null;
}

@Override
public Void visitT_constructorDeclaration(T_constructorDeclarationContext ctx) {
  final String constructorId = idWithLC("constructor", ctx.UndecoratedIdentifier().getSymbol());
  executableVisit(constructorId, ctx);
  return null;
}

/** An identifier for a token constructed from the prependString, the line that the forToken is on,
 * and the position in the line for the first character of the forToken. For implementation reasons
 * the line number starts counting with one, but the character position in the line starts counting
 * with zero. Example: the identifier for the starting token of a block might be
 * <code>block-L24C4</code>. */
private String idWithLC(String prependString, Token forToken) {
  return idWithLC(prependString, "", forToken);
}

/** An identifier for a token constructed from the prependString, the line that the forToken is on,
 * the position in the line for the first character of the forToken, and an appendString. For
 * implementation reasons the line number starts counting with one, but the character position in
 * the line starts counting with zero. Example: the identifier for a method might be
 * <code>method-L24C12-toString</code>. */
private String idWithLC(String prependString, String appendString, Token forToken) {
  int line = forToken.getLine();
  int charPosition = forToken.getCharPositionInLine();
  return prependString + "-L" + line + "C" + charPosition + "-" + appendString;
}

/** Visit the code contained in an executable, that is, a method, constructor, or the object's
 * initializer blocks.
 * <p>
 * The complication is that we have to make a fresh copy of the field-level scope information for
 * each executable. This is because in a scope, its variable information is the place that we need
 * to keep the value information for that variable, even if the value is assigned in an enclosed
 * scope; values that are assigned to a variable in
 * an enclosed scope continue to exist after the enclosed scope ends, so the name of the value
 * continues to exist in the variables scope object. But for the object's fields, this creates a
 * problem.
 * <p>
 * In order to make status statements in an executable independent of other executables, the
 * executable must assume only the information about fields that is in the object level constraints,
 * which means that that the executable has no knowledge of the exact values assigned to the fields
 * by other executables. Therefore, to keep the field values and names assigned in executables
 * separate, each executable starts with a fresh copy of the field scope as its enclosing scope,
 * which we call the background scope, and it holds only the starting value names for each field.
 *
 * @param id
 *                          a unique name for the executable, for use in error messages
 * @param executableContext
 */
private void executableVisit(String id, ParserRuleContext executableContext) {
  final Scope grandParent = currentScope; // push

  BackgroundScope backgroundParent = new BackgroundScope(program, "background-" + id, grandParent);
  visitCodeScope(id, executableContext, backgroundParent);
  backgroundParent.clearForCodeGeneration();

  currentScope = grandParent; // pop
}


/** Perform tasks common to all new executable scopes.
 * @param id          A unique ID for this scope
 * @param ctx         The parse context for the executable scope that is visited
 * @param parentScope The enclosing scope, normally the global <code>currentScope</code> */
private void visitCodeScope(String id, ParserRuleContext ctx, Scope parentScope) {
  currentScope = new Scope(program, id, parentScope);
  scopeMap.put(ctx, currentScope);
  final boolean enclosingIsInExecutable = isInExecutable;
  isInExecutable = true;

  visitChildren(ctx);

  isInExecutable = enclosingIsInExecutable;
  currentScope.clearForCodeGeneration();
  currentScope = parentScope; // restore global currentScope
}

@Override
public Void visitT_block(T_blockContext ctx) {
  final Token firstToken = ctx.getStart();
  final int startingChar = firstToken.getCharPositionInLine();
  String blockLabel = "block_L" + firstToken.getLine() + "C" + startingChar;
  final Scope parent = currentScope;
  currentScope = new Scope(program, blockLabel, parent);
  scopeMap.put(ctx, currentScope);

  visitChildren(ctx);

  currentScope.clearForCodeGeneration();
  currentScope = parent;
  return null;
}

@Override
public Void visitAssignStmt(AssignStmtContext ctx) {
  /* we reverse the order of visiting the children because assignment happens after the expression
   * is evaluated. This is important because we don't want to change the current value in the
   * variable info until the end of the assignment. */
  visit(ctx.t_expression());
  visit(ctx.t_assignable());
  return null;
}

@Override
public Void visitT_assignable(T_assignableContext ctx) {
  final boolean oldInAssignment = isInAssignment;
  isInAssignment = true;

  visitChildren(ctx);

  isInAssignment = oldInAssignment;
  return null;
}

/** {@inheritDoc} */
@Override
public Void visitT_initializedVariableDeclaratorId(T_initializedVariableDeclaratorIdContext ctx) {
  final T_idDeclarationContext declCtx = ctx.t_idDeclaration();
  final Token valueNameToken = declCtx.getStart();
  String valueName = valueNameToken.getText();
  if (isMidDecorated(valueNameToken)) {
    errs.collectError(program, valueNameToken, "Variable declarations cannot be mid-decorated");
  } else if (isUndecorated(valueNameToken)) {
    errs.collectError(program, valueNameToken,
                      "Initialized variable declarations must be decorated");
    // hoping to improve err msgs for following code:
    valueName = "'" + valueName;
  }
  Optional<VarInfo> newVarInfo = currentScope.declareVarName(valueNameToken, declCtx.idType);
  if (isMissing(newVarInfo))
    recoverFromRedeclaredVariable(valueNameToken);
  return null;
}

/** Issue error message, but then treat this as though it were a new value name in hopes of finding
 * more useful errors */
private void recoverFromRedeclaredVariable(final Token valueNameToken) {
  String valueName = valueNameToken.getText();
  String varName = variableName(valueName);
  VarInfo existingVarInfo = currentScope.getConflictingVarDeclarationInfo(varName);
  String msg = "Attempted to declare variable "+ varName
              +", but it was already declared at line "+  existingVarInfo.getLineWhereDeclared();
  errs.collectError(program, valueNameToken, msg);
  defineTheValueNameRegardlessOfErrors(valueNameToken, existingVarInfo);
}

@Override
public Void
visitT_uninitializedVariableDeclaratorId(T_uninitializedVariableDeclaratorIdContext ctx) {
  final T_idDeclarationContext declCtx = ctx.t_idDeclaration();
  final Token varNameToken = declCtx.getStart();
  if (isDecorated(varNameToken))
    errs.collectError(program, varNameToken,
                      "A variable declaration may not be decorated unless it is initialized");
  Optional<VarInfo> varInfo = currentScope.declareVarName(varNameToken, declCtx.idType);
  if  (isMissing(varInfo))
    recoverFromRedeclaredVariable(varNameToken);
  return null;
}

@Override
public Void visitT_means(T_meansContext ctx) {
  final boolean oldInLogic = isInLogic;
  isInLogic = true;

  visitChildren(ctx);

  isInLogic = oldInLogic;
  return null;
}

@Override
public Void visitT_expression(T_expressionContext ctx) {
  final boolean oldInAssignment = isInAssignment;
  isInAssignment = false;

  visitChildren(ctx);

  isInAssignment = oldInAssignment;
  return null;
}

@Override
public Void visitT_identifier(T_identifierContext ctx) {
  final Token idToken = ctx.start;
  checkForReservedChars(idToken);

  // TODO: try removing next line. Isn't isInExecutable sufficient?
  if (currentScope != null)  // i.e., we are inside a type definition
    if (isInExecutable)
      if (isInAssignment)
        checkAssignment(ctx);
      else
        checkReference(ctx);

  visitChildren(ctx);
  return null;
}

//@formatter:off
//The rest of the program has not been checked for preserving readability


// *************** Helper methods *******************************

public void typeDeclarationVisit(String typeName, ParserRuleContext ctx) {
  // Assumption: field visitor has created a Scope object and loaded it
  // with class fields (and their value names if they were initialized) but it has not
  // filled in the parent scope for that Scope object except for the instance of the top level type.
  // We let the Java compiler check for a single visible top-level type per file.
  final Scope parent = currentScope;
  final Scope savedClassScopeFromFieldVisitor = scopeMap.get(ctx);

  if (thisIsTheTopLevelType()) { topTypeName = typeName; }
  if (savedClassScopeFromFieldVisitor == null) { //push new
    currentScope = new Scope(program, typeName, parent);
    scopeMap.put(ctx, currentScope);
  } else { //or push existing
    setParentIfInnerClass(savedClassScopeFromFieldVisitor, parent);
    currentScope = savedClassScopeFromFieldVisitor;
  }

  visitChildren(ctx);

  currentScope.clearForCodeGeneration();
  currentScope = parent; //pop
}

private void setParentIfInnerClass(Scope possibleInnerClass, Scope parent) {
  if (possibleInnerClass.parent == null)  // yes, it's an inner class
    possibleInnerClass.setParent(currentScope);
}

/** Check for possible values in a value name that is being assigned a value.
 * @implementation We Define the new value name, even if there was an error, in hopes of finding
 *                 additional useful errors. If there was not a valid value name, we construct one
 *                 to work with.
 */
private void checkAssignment(T_identifierContext ctx) {
  Token valueNameToken = ctx.start;
  final VarInfo varInfo = getVarInfo(valueNameToken);
  variableName(valueNameToken);

  checkForAlreadyFinalValue(valueNameToken, varInfo);
  String valueName = workingValueName(valueNameToken);


  if (isInInitialBranch) {
    checkForOverwritingAValuename(valueNameToken, varInfo);
    nestedValueNames.add(valueName);
    defineTheValueNameRegardlessOfErrors(valueNameToken, varInfo);
  } else if (isInFollowingBranch) {

    // TODO: if a following branch takes a valueName out of order,
    //       we must use $T$ for for that variable's current value
    if ( ! nestedValueNames.remove(valueName))
      errs.collectError( program, valueNameToken, "value name "+ valueName
              +" is not defined for the initial branch of the conditional statement");
    // valueName was defined in initial branch, so we don't need to do that here
  } else {
    checkForOverwritingAValuename(valueNameToken, varInfo);
    defineTheValueNameRegardlessOfErrors(valueNameToken, varInfo);
  }
}

/** Proceed with valueName definition, even if there were errors, in hopes of generating better
 * error messages for the following code */
private void defineTheValueNameRegardlessOfErrors(Token valueNameToken, VarInfo varInfo) {
  varInfo.defineNewValue(valueNameToken);
}

/** check decorated value name for prior definition */
private void checkForOverwritingAValuename(Token valueNameToken, VarInfo varInfo) {
  String valueName = valueNameToken.getText();
  Integer existingValueLineNum = varInfo.lineOf(valueName);
  final boolean valueAlreadyExists = (existingValueLineNum != null);
  if (valueAlreadyExists) {
    final String msg = String.format
      ("The value %s has already been defined on line %d"
      , valueName, existingValueLineNum
      );
    errs.collectError( program, valueNameToken, msg);
  }
}

/** Either the originally coded value name or a kludged one to allow catching more error messages.
 */
private String workingValueName(Token valueNameToken) {
  if (isUndecorated(valueNameToken)) {
    errs.collectError( program, valueNameToken,
          valueNameToken.getText() +" is not a decorated value name so it cannot receive a value");
    return kludgedValueName(valueNameToken);
  } else
    return valueNameToken.getText();
}

/** A value name generated purely in hopes of helping to generate additional helpful error messages
 */
private String kludgedValueName(Token valueNameToken) {
  return "'$T$"+ variableName(valueNameToken);
}

/** Check to see if this variable was already assigned a final value. If so, we issue an error
 * message but proceed with error checking using the new value name in hopes of finding some more
 * useful errors.
 * @implementaion Check the current value name for the variable to see if it is final decorated. */
private void checkForAlreadyFinalValue(Token valueNameToken, VarInfo varInfo) {
  String varName = variableName(valueNameToken);
  String valueName = valueNameToken.getText();
  final String currentValueName = varInfo.getCurrentValueName();
  if ( isAlreadyFinallyDecorated(currentValueName) && ! reassigningInFollowingBranch(valueName)) {
    final String msg = String.format
        ("%s was final decorated at line %d so it cannot receive a new value"
        , varName, varInfo.lineOf(currentValueName)
        );
    errs.collectError( program, valueNameToken, msg);
  }
}

private boolean reassigningInFollowingBranch(String valueName) {
  return isInFollowingBranch && nestedValueNames.contains(valueName);
}

private VarInfo getVarInfo(Token valueNameToken) {
  Optional<VarInfo> OptVar = currentScope.getOptionalExistingVarInfo(variableName(valueNameToken));
  if ( isMissing(OptVar) ) {
    errs.collectError( program, valueNameToken, "Variable "+variableName(valueNameToken)+" has not been defined in this scope");
    OptVar = currentScope.declareVarName(valueNameToken, "UnknownType_UndeclaredVariable$T$");
  }
  final VarInfo varInfo = OptVar.get();
  return varInfo;
}
/**
 * @param OptVar
 * @return
 */
private boolean isMissing(Optional<?> OptVar) {
  return ! OptVar.isPresent();
}
/**
 * @param currentValueName
 * @return
 */
private boolean isAlreadyFinallyDecorated(String currentValueName) {
  boolean hasCurrentValue = (currentValueName != null);
  return hasCurrentValue && isFinalDecorated(currentValueName);
}

private void checkReference(T_identifierContext ctx) {
  final Token valueNameToken = ctx.getStart();
  String valueName = valueNameToken.getText();
  final String varName = variableName(valueName);
  VarInfo varInfo = currentScope.getOptionalExistingVarInfo(varName).orElse(null);
  if ( varInfo == null) { // variable is not in scope
    final String msg = String.format("Variable %s has not been defined in this scope", varName);
    errs.collectError( program, valueNameToken , msg);
    varInfo = attemptRecoveryForMissingVariable(valueNameToken);
  } else { // var is in scope
    if ( ! valueName.equals(varInfo.getCurrentValueName())) {
      if (varInfo.hasDefinedValue(valueName)) {
        if (isInExecutable && ! isInLogic) {
          varInfo.reusedValueNames.add(valueName);
        }
      } else {
        errorAndRecoveryForReferenceToUndefinedValue(valueNameToken, varInfo);
      }
    }
  }
}

private void errorAndRecoveryForReferenceToUndefinedValue(Token valueNameToken, VarInfo varInfo) {
  String valueName = valueNameToken.getText();
  if (isDecorated(valueNameToken)) {
    final String msg = String.format("Value %s has not been defined", valueName);
    errs.collectError( program, valueNameToken, msg);
  } else {
    issueUndecoratedMsg(valueNameToken);
    // construct an arbitrary value name for better error msgs in the following code
    // TODO: use "'$T$" + valuename (will need to include it in the Lexer and Parser)
    valueName = "'"+ valueName;
  }
  defineTheValueNameRegardlessOfErrors(valueNameToken, varInfo);
}

/** We generate the missing VarInfo and make sure that it has some current value decoration, hoping
 * that this will result in generating better error messages in the following code.
 * <p>
 * ASSUMES: the variable for the valueNameToken has not been declared yet
 *  @return A dummy VarInfo for the non-existent variable
 */
private VarInfo attemptRecoveryForMissingVariable(Token valueNameToken) {
  VarInfo varInfo = currentScope.declareVarName(valueNameToken, "NoTypeForUndeclaredReference")
                                .get();
  if (isUndecorated(valueNameToken)) {
    final String valueName = valueNameToken.getText();
    issueUndecoratedMsg(valueNameToken);
    // we assume an initial decoration to allow more checking
    varInfo.defineNewValue("'"+ valueName, valueNameToken.getLine());
  }
  return varInfo;
}

private void issueUndecoratedMsg(Token valueNameToken) {
  final String undecoratedMsg = "A reference to a value must be a value name: "
                              + valueNameToken.getText() +" must be decorated";
  errs.collectError(program, valueNameToken, undecoratedMsg);
}

String checkedText(TerminalNode id) {
  checkForReservedChars(id.getSymbol());
  return id.getText();
}

private void checkForReservedChars(final Token idToken) {
  final String id = idToken.getText();
  if (id.contains(reservedCharString)) {
    errs.collectError(program, idToken , invalidCharsMsg);
  }
}

//TODO include rest of visit methods for value related code

} // end class FieldVisitor
