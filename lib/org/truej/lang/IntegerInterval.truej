/** The mathematical integers, but restricted to an interval for twos-complement computation.
 * Therefore, there is a maximum and minimum for the IntegerInterval and no operation may have a
 * result outside the interval. The twos-complement results in half of the interval
 * being negative and the other half zero or positive.
 *
 * We define methods that serve as a foundational definition of TrueJ integer operators.
 * Although TrueJ does not allow operator overloading, we use the Groovy function names for
 * overloading operators in an attempt to provide consistency across the field of programming. The
 * <code>phrase <></code> clause provides a facility that is similar to overloading
 * but it is restricted to use within a scope.
 *
 * A phrase is used to define the abbreviation "I" for "IntegerInterval".
 */
public abstract class IntegerInterval phrase <I> {

exemplars I   i', j', k', n';

/** Zero is a member of the IntegerInterval. Each integer implementation uses the numeral 0 for its
 * implementation of this value.
 * We include a phrase for the numeral 0 so that when we use an expression like <code> 1 + 0 </code>
 * here in the definition of IntegerInterval, we are referring to the method zero().
 * and not any particular implementation's 0. */
public abstract static  I  zero() phrase <0>;

/** One is an a member of the IntegerInterval. Each implementation uses the numeral 1 for this value.
 * We include a phrase for the numeral 1 so that when we use an expression like <code> 1 + 0 </code>
 * here in the definition of IntegerInterval, we are referring to the method one().
 * and not any particular implementation's 1. */
public abstract static  I  one() phrase <1>;

/** The maximum integer allowed for the implementation. Each implementation defines a constant for
 * this value that is named MAX_VALUE for consistency. As the maximum of a twos-complement
 * implementation, this will have a value of 2<sup>n</sup>-1; for instance, for integers stored in
 * a Byte, the value of n will be 8 so the Byte.maxValue() = Byte.MAX_VALUE = 127.
 */
public abstract static I maxValue();

/** The minimum integer allowed for the implementation. Each implementation defines a constant for
 * this value that is named MIN_VALUE for consistency. As the minimum of a twos-complement
 * implementation, this will have a value of -2<sup>n</sup>; for instance, for integers stored in
 * bytes, the value of n will be 8 so the result of both Byte.minValue() and Byte.MIN_VALUE will be
 * -128. */
public abstract static I minValue();

/** Note that the interval maximum and minimum restrictions on the results of operations means that
 * axioms and theorems do not apply when those restrictions are violated, keeping them simple and
 * similar to the axioms of mathematical integers.
 */
 IntegerBounds: axiom minValue() <= i' <= maxValue;

/** Addition is the plus(a,b) method. This is a method corresponding to the implemented addition
 * operation for each subclass. The system maps addition to the binary operator <code> + </code> for
 * each subclass implementation, but those are not available to us in this abstract superclass. To
 * make the code readable, we provide a phrase that lets us refer to the plus() method here in the
 * definition of IntegerInterval with <code> + </code>.
 * <p>
 * Usage: <code>a' + b'</code> or <code>plus(a',b')</code> */
public abstract static I plus(I a', I b') phrase <a' + b'>;
  given minValue() <= a' + b' <= maxValue();
  /* Note that the IntegerBounds axiom ensures that the return value of plus(a',b') is in the valid
   * interval. So the <code>given</code> statement is redundant, but we state it to make clear that
   * the parameters a' and b' are constrained. */

/** Addition of integers is associative so there is no mathematical need to parenthesize them.
  * <p>
  * Once this is established we can consider the operational order of additions. All subclasses,
  * that is, all implementations of integers, use a right to left order of operations for addition,
  * so the expression <code>i' + j' + k</code> is operationally eqivalent to
  * <code>(i' + j') + k</code>. But because that is mathematically equivalent to
  * <code>i' + (j' + k)</code>, they are all operationally eqivalent, too. In fact, parentheses for
  * ordering additions are a syntax issue and the system never sees them. */
AssociativityOfAdditon: axiom (i' + j') + k' = i' + (j' + k') = i' + j' + k';

private theorem  i' + j' + k' + n' = i' + (j' + k') + n' = (i' + j') + (k' + n');

SymmetryOfAddition: axiom i' + j' = j' + i';

private theorem  i' + j' + k' = k' + j' + i';

AdditiveIdentity: axiom i' + 0 = i';

public theorem  0 + i' = i';

/** Integer multiplication.
   <p> Usage: a + b or multiply(a,b) */
public abstract static I multiply(I a', I b') private phrase <a' * b'>;
  given minValue() <= a' * b' <= maxValue();

AssociativityOfMultiplication: axiom (i' * j') * k' = i' * (j' * k');

SymmetryOfMultiplication: axiom i' * j' = j' * i';

MultiplicativeIdentity: axiom i' * 1 = i';

public theorem 1 * i' = i';

/** Multiplication * is stickier than + in the way that the syntax is processed so parentheses can
 * be omitted when adding multiplication expressions, though not when multiplying addition
 * expressions. */
DistributionOfMultiplicationOverAddition:
  axiom  i' * (j' + k') = i'*j' + i'*k';

/** Every member of the IntegerInterval has a negative(), with the exception of minValue(). The
 * system uses the prefix operator <code> - </code> for this in each integer implementation. We
 * include a phrase for the operator so that when we use an expression like <code> -a </code>
 * here in the definition of IntegerInterval, we are referring to the method
 * negative(a) and not any particular implementation's prefix <code> - </code> operator.
   <p> Usage: <code> -a'</code> or <code>negative(a')</code> */
public abstract static I negative(I a') private phrase <- a'>;
  given  a' != minValue();
  means  a' + negative(a') = 0;

/** Subtraction is the minus(a,b) method. This is a method corresponding to the implemented
 * subtraction operation for each subclass. The system maps subtraction to the binary
 * operator <code> - </code> for each subclass implementation, but those are not available to us
 * in this abstract superclass. To make the code readable, we provide a phrase that lets us
 * refer to the minus() method here in the definition of IntegerInterval with <code> - </code>.
 * <p>
 * Usage: <code>a' - b'</code> or <code>minus(a',b')</code> */
public abstract static  I minus(I a', I b') private phrase <a' - b'>;
  given minValue() <= a' - b' <= maxValue();
  /* Note that the IntegerBounds axiom ensures that the return value of minus(a',b') is in the valid
   * interval. So the <code>given</code> statement is redundant, but we state it to make clear that
   * the parameters a' and b' are constrained. */
  means return = a' + -b';

/** IntegerInterval division, which leaves a remainder. We map the div(n,d) method to the
 * <code>div</code> operator, saving the operator / for division that does not leave a remainder,
 * as in rational number division.
 * <p> Usage: n div d or div(n,d)
 * @see Definition of integer division in Java Language Specification, Topic 15.17.2 */
public abstract static  I div(I n', I d') private phrase <n' div d'>;
  given d' != 0 & !(n' = minValue() & d' = -1);
  means forsome I remainder
      ( n' = return' * d' + remainder'
      &   (sameSignLax(n',d') ==> 0 <= remainder < d')
      & ! (sameSignLax(n',d') ==> 0 >= remainder > d')
      );

/** The remainder of integer division, We map the mod() method to the operator <code> % </code>.
   <p> Usage: a % b or mod(a,b)
   @see Definition of the remainder, % (Java Language Specification, Topic 15.17.3)
   @see intdiv */
public abstract static  I mod(I a, I b) private phrase <a % b>;
  given b != 0;
  means forsome I quotient
      ( a = quotient * b + return
      &   (sameSignLax(a,b) ==> 0 <= return < b)
      & ! (sameSignLax(a,b) ==> 0 >= return > b)
  ;

/** Do the parameters have the same sign? Returns true if either is zero. */
public abstract static boolean sameSignLax(I a, I b) {
  if (a>=0)
    return = b>=0;
  else
    return = b<=0;
  }
  means a>=0 ==> return = b>=0
      & a<0  ==> return = b<=0;
    /*  or return = (a>=0) ? b>=0 : b<=0; */

theorem  (i div j)*j + (i % j) = i;

/** Integer division with a remainder. We provide for computing the quotient and remainder in a
   single operation.
   @see div()
   @see mod() */
public abstract static  I intDiv(I dividend', I divisor', I 'quotient, I 'remainder);
  given divisor' != 0
      & !(dividend' = minValue() & divisor' = -1);
  means dividend div divisor = quotient
      & dividend  %  divisor = remainder
  ;

// ******************************
// *** Consistency components ***
// ******************************
public String toString();

public abstract static  equals(Object other'); // Leave type of o as Object
  means this' = other' ==>  return = true                // Reflexive
      & return = other'.equals(this')                    // Symmetric
      & i'.equals(j') & j'.equals(k') ==> i'.equals(k'); // Transitive
      // therefore equals() is an equivalence relation

public abstract static int hashCode();
  means equals(i') ==> return = i'.hashCode();


public abstract static int compareTo(Name other);
//{
//// required for Comparable objects
////
//  if      (this.a < other.a)    { return -1; }
//  else if (this.equals(other))  { return  0; }
//  else                          { return +1; }
//}

public abstract static Object clone();
//{ // shallow copy
//  return new Name(a);
//}

} // end class Name

/* Copyright George S. Cowan, 2009. MIT open source license. */