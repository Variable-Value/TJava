                                        // Copyright George S. Cowan, 2019. MIT open source license.
/**
    An element of the integral domain, a mathematical integer. We use the name IntegralElement here
    and reserve the name Integer for 32-bit, 2s-complement bounded integers in order to stay
    parallel to Java. Because the mathematical integers have no upper and lower limits, they cannot
    be implemented in a finite computer (though an almost complete implementation could be made that
    only represented those integers needed for a finite computation).
    <p>
    Function Modifiers:
      Many computations produce a single value, and rather than force the programmer to choose a
      name for that value we can use the computation itself.
      treat those as a value rather than a statement can . Because TrueJ uses values, the
      compiler allows us to freely substitute equals for one another
      in logic statements, and the syntax makes it very clear when this helpful property is or is
      not available. When substitution of equals is not available we can fall back on the general
      way that TrueJ makes programming easier, viewing a computation as a statement that relates the
      ending values of the state produced to the beginning values of the state that were used, where
      the "return" value being equal to something is just one small statement that is part of a more
      complicated logical statement.

      If we can treat a computation as a single value, then the syntax for the computation can be
      used as the notation for the functional relationship between its inputs and its output. We can
      substitute this functional syntax for the name of the value, or for another computation that
      produces the same value. This referential transparency from computations to their values
      requires four conditions on each such computation:
        (1) it must be determinate or pure, with its result completely determined by the
            syntactically provided inputs
        (2) it must provide a value with no side effects, that is, no other visible changes to the
            state
        (3) all preconditions on the computation must hold; for instance, the "no division by zero"
            rule may be obeyed with with code like
              <code>hourlyRate = totPay/hoursWorked & hoursWorked != 0</code>
        (4) any exceptions that might happen in the computations must be either so catastrophic that
            they clearly signal that all logical statements about the computations are void, like a
            system crash, or logical statements including the computation must have a
            disjunction that specifies that the exception is an alternative; for instance an
            alternative to treating the "no division by zero" rule as a precondition would be
              <code>hourlyRate = totPay/hoursWorked | ArithmethicException
            or, if possible,
              <pre><code>
                  hourlyRate = totPay/hoursWorked & hoursWorked != 0
                | ArithmethicException            & hoursWorked  = 0
              </code></pre>

      Normally in methods with a returned result, that result is determined by the current state of
      the object and the method parameters, all of which are decorated to identify a particular
      state.




    All the methods of IntegralElement have the <code>total function</code> modifiers. The
    <code>total</code> modifier prevents given-statements and all but catastrophic exceptions,
    ensuring the existence of the result. This is needed to in order to extablish the (implicit)
    closure axioms for operators. If they were not marked with the <code>function</code> modifier,
    then we could not count on the result being determined by the values of their parameters
    together with <code>this</code>, and TrueJ would require us to code unique decorations for
    <code>this</code> on every call. This is TrueJ's way of enforcing the higher level Leibnitz
    axiom, "Equals can always be substituted for equals". For example, <code>Math'.random()</code>
    always requires a unique decoration on <code>Math</code> to show that its result is not
    determinate and to help us see that the values are different. The <code>function</code> modifier
    also prevents the method from having any visible side effects. and allowing us to use
    substitution of equals freely.
 */
public interface IntegralElement extends Comparable {
exemplar IntegralElement n', i', j', k';

/**
    Zero is an integer. The <code>zero()</code> method is the backing function for the constant
    literal <code>0</code>.
 */
public static total function IntegralElement zero();

/**
    One is an integer. The <code>one()</code> method is the backing function for the constant
    literal <code>1</code>.
 */
public static total function IntegralElement one();

axiom 1 != 0;

/**
  Addition of integers is the <code> plus(addend') </code> method. The system allows the
  <code> + </code> operator to be used for any type that defines a <code>plus(x')</code> function,
  i.e., <code>plus(x')</code> serves as the <code> + </code> operator's backing definition.
  <p>
  Usage: <code>a' + b'</code> or <code> a'.plus(b') </code>
 */
public total function IntegralElement plus(IntegralElement addend');

/**
  Functional form of Uniqueness of addition. Because <code>this'.plus(addend')</code> is a function,
  the system has already made the following statement an axiom; it corresponds to the Uniqueness
  Axiom for addition. By coding it here as a private theorem , we are verifying that it was implicitly
  implemented by the system. The prover uses the Leibnitz rule to prove the theorem.
  <p>
  We restate the Uniqueness Axiom in its more usual form with the easier to read <code>+</code>
  operator the following theorem, Uniqueness of addition.
 */
FunctionPlus: private theorem  i' = j'  ==>  this'.plus(i') = this'.plus(j');

/**
  Uniqueness of addition. Equals can be added to or subtracted from both sides of an equation.
 */
UniquenessOfAddition: theorem i' = j' & k' = n'  ==>  i' + k' = j' + n';

AssociativityOfAddition: axiom (i' + j') + k' = i' + (j' + k');

SymmetryOfAddition: axiom i' + j' = j' + i';

AdditiveIdentity: axiom n' + 0 = n';

UniquenessOfAdditiveIdentity: theorem i' + j' = i'  ===  j' = 0;
  (because i' + j' = i'
         = i' + j' = i' + 0 (because of AdditiveIdentity)
         =      j' =      0 (because of CancelationOfAddition)
  )

/**
  Additive Inverse. Every integer has a corresponding additive inverse, its negation. The system
  allows the unary <code>-</code> operator to be used for any type that defines a
  <code>negative()</code> function, i.e., <code>negative()</code> serves as the <code>-</code>
  operator's backing definition. We will show in a theorem that <code>0.negative() = 0</code>.
  <p>
  Usage: <code>-n'</code> or <code> n'.negative() </code>
 */
public total function IntegralElement negative();
means this' + return' = 0;

/**
  The unary minus can be used for the additive inverse of an IntegralElement.
 */
AdditiveInverse: theorem k' + -k' = 0;

/** Cancellation Theorem for addition. Equal sums allow cancellation of equal addends. */
CancellationOfAddition: theorem k' + i' = k' + j'  ===  i' = j'
  (because        k' + i'  =        k' + j'
       ==>  -k + (k' + i') =  -k + (k' + j') (because of UniquenessOfAddition)
       === (-k + k') + i'  = (-k + k') + j'  (because of AssociativityOfAddition)
       ===         0 + i'  =         0 + j'  (because of AdditiveInverse)
       ===             i'  =             j'  (because of AdditiveIdentity)
  );
// Alternatively,
//  (because 1. k' + i' = k' + j'  ==>  i' = j' (because
//           1.1 assuming k' + i' = k' + j';
//           1.2.            i'
//              = 0        + i' (because of AdditiveIdentity)
//              = -k' + k' + i' (because of AdditiveInverse)
//              = -k' + k' + j' (because of 1.1. & SubstitutionOfEquals)
//              = 0        + j' (because of AdditiveInverse)
//              =            j' (because of AdditiveIdentity)
//           );
//           2. k' + i' = k' + j' <== i' = j' (because
//           2.1. assuming i' = j';
//           2.2. k' + i'
//              = k' + j' (because of SubstitutionOfEquals)
//           );
//           7. k' + i' = k' + j'  ===  i' = j' (because of 1., 2.);
//           QED
//  );

/**
  Multiplication of integers is the <code>multiply(multiplier')</code> method. The system allows the
  <code>*</code> operator to be used for any type that defines a <code>multiply(x')</code> function,
  i.e., <code>multiply(x')</code> serves as the <code>*</code> operator's backing definition. The
  <code>*</code> operator binds tighter than <code>+</code>, so
  <code>i' * j' + n' = (i' * j') + n'</code>.
  <p>
  Usage: a' * b' or a'.multiply(b)
 */
public total function IntegralElement multiply(IntegralElement multiplier');

/**
  Functional form of Uniqueness of multiplication. Because <code>multiply(multiplier')</code> is a
  function, the system has already made the following statement an axiom; it corresponds to the
  Uniqueness Axiom for multiplication. By coding it here as a theorem, we are verifying that it was
  implicitly implemented by the system. (A function is not allowed to have a side-effect and its
  result is determinate.)
 */
FunctionMultiply: private theorem  i' = j'  ==>  this'.multiply(i') = this'.multiply(j');

/**
  Uniqueness of multiplication. Equals can multiply both sides of an equation.
  <p>
  We restate the Uniqueness Axiom in its more usual form with the easier to read <code>*</code>
  operator. In actuality, the TrueJ system always obeys the Leibnitz axiom, "Equals can always be
  substituted for equals".
 */
UniquenessOfMultiplication:
  theorem i' = j' & k' = n'  ==>  i' * k' = j' * n'
    (because i' = j' &      k' =      n'
         ==> i' = j' & i' * k' = i' * n' (because of FunctionMultiply)
         ==>           i' * k' = j' * n' (because of Leibnitz)
    );

AssociativityOfMultiplication: axiom (i' * j') * k' = i' * (j' * k');

SymmetryOfMultiplication: axiom i' * j' = j' * i';

MultiplicativeIdentity: axiom n' * 1 = n';

MultiplicationDistributesOverAddition: axiom n' * (i' + j') = n'*i' + n'*j';

/**
  Cancellation Axiom for multiplication. Equal products allow cancellation of non-zero multipliers.
  This must be an axiom instead of a theorem because the integers do not generally have a
  multiplcative inverse.
 */
CancelationOfMultiplication: axiom k' != 0  ==>  (k' * i' = k' * j'  ===  i' = j');

/**
  Zero theorem for multiplication.
 */
Zero: theorem n' * 0 = 0
  (because true
       === n'*n'         = n'*n'
       === n'*(n' + 0)   = n'*n' + 0 (because of AdditiveIdentity)
       === n'*n'  + n'*0 = n'*n' + 0 (because of DistributionOfMultiplicationOverAddition)
       ===          n'*0 =         0 (because of CancellationOfAddition)
  );

ZeroProduct: theorem i'*j' = 0  ===  i' = 0 | j' = 0
  (because i'    = 0    | j'    =    0
       === i'*j' = 0*j' | i'*j' = i'*0 (because of Zero)
       === i'*j' = 0    | i'*j' =    0 (because of Zero)
       === i'*j' = 0
  );

/**
  <code>i'+n'=0</code> means that <code>i'=-n'</code>, and there is only one additive inverse for
  <code>n'</code>.
 */
UniqueAdditiveInverse: i' + n' = 0 & j' + n' = 0  ==>  i' = j'
  (because i' + n' = 0 & j' + n' = 0
       ==> i' + n'     = j' + n'
       === i'          = j'      (because of CancellationOfAddition)
  );

/**
  Subtraction of integers is the <code>minus(subtrahend')</code> method. <code>this</code> is the
  minuend, from which the subtrahend is subtracted.
  <p>
  The system allows the <code>-</code> operator to be used for any type that defines a
  <code>minus(x')</code> function, which serves as the operator's backing definition.
  <p>
  Usage: <code>a' - b'</code> or <code> a'.minus(b') </code>
  */
public total function IntegralElement minus(IntegralElement subtrahend');
means return' = this' + -subtrahend';

Subtraction: theorem i' - j' = i' + -j';

GS_15_15: theorem i' + n' = 0  ===  i' = -n';
GS_15_16: theorem -i' = -j'  ===  i' = j';
GS_15_17: theorem -(-n') = n';
GS_15_18: theorem -0 = 0;
GS_15_19: theorem -(i' + j') = -i' + -j';
GS_15_20: theorem -n' = -1 * n';
GS_15_21: theorem -i' * j' = i' * -j';
GS_15_22: theorem i' * -j' = -(i'*j');
GS_15_23: theorem -i' * -j' = i'*j';
GS_15_24: theorem n' - 0 = n';
GS_15_25: theorem (i' - j') + (k' - n') = (i' + k') - (j' + n');
GS_15_26: theorem (i' - j') - (k' - n') = (i' + n') - (j' + k');
GS_15_27: theorem (i' - j')*(k' - n') = (i'*k' + j'*n') - (i'*n' + j'*k');
GS_15_28: theorem i' - j' = k' - n'  ===  i' + n' = j' + k';
GS_15_29: theorem (i' - j')*k' = i'*k' - j'*k';

/**
  We use the notion of positive integers to formalize the domain of IntegralElements as an Ordered
  Domain, following G&S, p. 307.
 */
public total function boolean positive() {
  return this'.compareTo(0) > 0;
};

AdditionOfPositives:       axiom i'.positive() & j'.positive()  ==>  (i' + j').positive();
MultiplicationOfPositives: axiom i'.positive() & j'.positive()  ==>  (i'*j').positive();
ZeroIsNotPositive:         axiom ! 0.positive();
NegativeIsNotPositive:     axiom i'!=0  ==>  (i'.positive()  ===  ! (-i').positive();

GS_15_34: theorem n'!=0  ==>  (n'*n').positive()
  (given   1. n'!=0
   because 2. n'.positive() | ! n'.positive() (because 1.)
           3. for (n'*n').positive();

           3.1. case n'.positive();
           3.1.1. (n'*n').positive() (because of MultiplicationOfPositives);

           3.2. case ! n'.positive();
           3.2.1.   n'.positive() === ! (-n').positive() (because 1., NegativeIsNotPositive);
           3.2.2. ! n'.positive() ===   (-n').positive();
           3.2.3.                       (-n').positive() (because 3.2., 3.2.2.);
           3.2.4. (-n').positive() & (-n').positive();
           3.2.5. (-n'*-n').positive() (because of MultiplicationOfPositives);
           3.2.6. ( n'* n').positive() (because -i' * -j' = i'*j')

           4. (n'*n').positive() (because 3.);
           QED
  );

GS_15_35: theorem i'.positive()  ==>  (j'.positive()  ===  (i'*j').positive());

theorem 1.positive()
  (because 1. 1 != 0;
           2. (1*1).positive() (because n'!=0  ==>  (n'*n').positive());
           3. 1*1 = 1 (because 1*n' = n');
           4. 1.positive();
  );

theorem ! (-1).positive();

/**
    Defines an Equivalence relation; that is, it is reflexive, symmetric, and transitive. Equality
    also obeys the Leibniz rule: "Two expressions are equal in all states iff replacing one by the
    other in any expression E does not change the value of E (in any state)" (G&S, p. 12). This
    cannot be stated as a first order theorem but we can verify that the prover supports this for
    the kinds of expressions that we are interested in.

    Since equality is reflexive and either of the two equal objects can be substituted for the other
    in any expression, then we have the corollary that two equal objects must have exactly the same
    type or be automatically converted.

    TODO: This will require some special thought with numeric types, e.g., <code>1 = 1.0</code>. Is
          promotion of integer types sufficient? The only problem that I can see at a glance is in
          assignments (<code>int a = 1;</code> vs. <code>int a = 1.0</code>) and method arguments
          (<code>anInteger.plus(1)</code> vs. <code>anInteger.plus(1.0)</code>). Hopefully, we can
          use the assumptions of Java automatic type conversion but we will need to require proof
          that a narrowing conversion will avoid an Exception. QUESTION: are there any numeric type
          promotions that only approximate the promoted value, e.g., are all long values
          representable by a float for both magnitude and acccuracy? (Refer to spec, Chapter 5.)

    Will the prover's understanding of equality ever be different that the run-time check for
    equality that we define here? If two objects may have different classes, e.g., one is be a
    subtype of the other, or both are referenced from a supertype variable where it is only the
    supertype characteristics that are relevant, then the programmer may want to explicitly force
    them to the same type, e.g., <code>(Circle)graphicArray[0] = currentCircle</code>. Perhaps such
    issues are dealt with by the fact that all definitions of equality must be consistent with the
    definition in the supertype.

    A check for parameter <code>other'</code> being null is not required because the parameter is
    not optional.

    The .equals(other') function serves as the backing function for the operators = and ===, the
    only difference being that = is syntactically stickier than ===; which means that === ends up
    being used to compare truth values that are created by = comparisons. Note that both are
    conjunctive, unlike the equivalence operator in G&S (p. 29).
 */
public total function boolean equals(Object other');

EqualityIsReflexive:  private theorem n' = n';
EqualityIsSymmetric:  private theorem i' = j'  ===  j' = i';
EqualityIsTransitive: private theorem i' = j' & j' = k'  ==>  i' = k';

/**
  The compareTo(other') function is the basis for less than and greater-than, and is synchronized
  with equality.
  <p>
  The system automatically uses compareTo as the backing function for the ordering relations:
  <pre>
    <  is mapped to a result of -1 or another negative number
    <= is mapped to a result of 0 or a negative number
    =  is mapped to this'.equals(other') but compareTo must return 0
    >= is mapped to a result of 0 or a positivie number
    <  is mapped to a result of +1 or another positive number
  </pre>
  <p>
  @return <pre>
          if this' > other' then +1 or other positive number
          if this' = other' then 0
          if this' < other' then -1 or other negative number </pre>
 */
public total function IntegralElement compareTo(IntegralElement other');
  means ( this'.equals(other')         ===  this'.compareTo(other') = 0 )
      & ( (this' - other').positive()  ===  this'.compareTo(other').positive() )
      & ( (other' - this').positive()  ===  this'.compareTo(other').negative().positive() );
        // note that the the methods .negative() and .positive() are used differently
        // x.negative() is the integer that is the negation of x
        // x.positive() is a true/false test
        // The following theorem is a simpler restatement of the intent of this means-statement

theorem ( this' = other'  ===  this'.compareTo(other') = 0 )
      & ( this' > other'  ===  this'.compareTo(other') > 0 )
      & ( this' < other'  ===  this'.compareTo(other') < 0 );

LessThan:    theorem i' <  j'  ===  (j' - i').positive();
GreaterThan: theorem i' >  j'  ===  (i' - j').positive();
AtMost:      theorem i' <= j'  ===  i' < j' | i' = j';
AtLeast:     theorem i' >= j'  ===  i' > j' | i' = j';

Positives: theorem i'.positive()  ===  0 < i';
Transitivity: theorem i' <  j' & j' <  k'  ==>  i' <  k'
                    & i' <= j' & j' <  k'  ==>  i' <  k'
                    & i' <  j' & j' <= k'  ==>  i' <  k'
                    & i' <= j' & j' <= k'  ==>  i' <= k';
MonotonicityOfAddition: theorem i' < j'  ===  i' + k' < j' + k';
MonotonicityOfMultiplication: theorem 0 < k'  ==>  (i' < j'  ===  i'*k' = j'*k');
Trichotomy: theorem ( (i' < k') & ~(i' > k') & k' != i')
                  | (~(i' < k') &  (i' > k') & k' != i')
                  | (~(i' < k') & ~(i' > k') & k'  = i');
// An alternative statement of Trichotomy
  private theorem (i' < k' | i' > k' | i' = k')
                & ~(i' < k' & i' > k')
                & ~(i' < k' & i' = k')
                & ~(i' > k' & i' = k');
TotalOrder: theorem i'<=j' | j'<=i';
Antisymmetry: theorem i' <= j' & j' <= i'  ==>  i' = j';
Reflexivity: theorem n' <= n';
private theorem i' = j'   ===   (k' <= i'  ===  k' <= j');

/*
  The Well-Ordering Priciple for positive integers (natural numbers)

  For us to ensure that loops eventually finish, we must be able to count down the number of
  iterations remaining. One mathematical structure that gives us this property is a well order, a
  set that is totally ordered set where every subset has a bottom element. The integers almost give
  us this property because they have a total order to the elements, but the subset of negative
  elements has no bottom element.The well-ordered sets that we mainly use are the positive integers,
  the non-negative integers, and any finite subset of the integers.

  The Integral Elements are totally ordered:

    i' <= j' | j' <= i'

  so all we need to do is show that our candidate sets are well founded. We have not defined
  theoretical sets yet so the following is slightly informal. Taking the non-negative integers as an
  example, they well founded because every set that has an element has a least element:

    NonNegativeIntegersAreWellOrdered:
      forall(TheoreticalSet<IntegralElement> S
        : forall(IntegralElement s: S : s>=0)
        : ~S.empty() === exists(int b:S : forall(int c : c < b : ~S.contains(c))
      )
  We also have
    PositiveIntegersAreWellOrdered
    FiniteSetsOfIntegersAreWellOrdered

  The least element of the positive integers is one. The least element of the non-negative integers
  is zero. And every finite set has a least element. All of these sets are well ordered and can be
  used for mathematical induction and therefore for limiting the number of executions of a loop.
 */

/* This is a theorem if we can state the Well-ordering Principle as an axiom. */
public axiom i' > 0  ==> i' >= 1;
/*
  by contradiction
    assume  1. ~ forall(IntegralElement i' :: i' > 0  ==> i' >= 1) (by contradiction);
    because 2. exists(IntegralElement i' :: ~ (i' > 0  ==> i' >= 1)) (by GeneralizedDeMorgan);
            3. exists(IntegralElement i' :: ~ (i' <= 0 | i' >= 1)) (by DefinitionOfImplication);
            4. exists(IntegralElement i' ::    i' >  0 & i' <  1 ) (by DeMorgan);
            5. exists(IntegralElement i' :: 0 < i' < 1);
            6. let TheoreticalSet<IntegralElement> S = setOf(IntegralElement s' :: 0 < s' < 1);
            7. S != TheoreticalSet<IntegralElement>.EMPTY_SET (by 5, 6);
            8. S.subsetOf(setOf(IntegralElement s' : 0 <= s' : true);
            9. S.leastExists() (by 8, NonNegativeIntegersAreWellOrdered);
           10. let IntegralElement least' = S.least();
           11. S.contains(least');
           12. 0 < least' < 1 (by 11, 6)
           13. 0 * least' < least' * least' < 1 * least' (by  MonotonicityOfMultiplication);
           14. 0 < least' * least' < least' & least' < 1 (by 11, 12);
           15. S.contains(least' * least') (by 14, 6);
           16. least' * least' < S.least() (by 14, 10);
           17. false (by 15, 16);
               QED
 */

/* There is no IntegralElement between 0 and 1 */
private theorem  ~(0 < i' < 1);

/**
    Whole division, which leaves a remainder, designed for integer division, but allowed for all
    numbers. We use the <code>n' div d'</code> operator, to avoid confusion over the <code>n' /
    d'</code> operator for division that does not leave a remainder but has a rational or
    floating-point quotient. The system allows the <code>div</code> operator to be used for any type
    that defines a <code>div(n',d')</code> function, i.e., <code>div(n',d')</code> serves as the
    <code>div</code> operator's backing definition.
    <pre>
    Examples 5 div  2 =  2 remainder  1    5 div  3 =  1 remainder  2    7 div  3 =  2 remainder  1
            -5 div -2 =  2 remainder -1   -5 div -3 =  1 remainder -2   -7 div -3 =  2 remainder -1
             5 div -2 = -2 remainder  1    5 div -3 = -1 remainder  2    7 div -3 = -2 remainder  1
            -5 div  2 = -2 remainder -1   -5 div  3 = -1 remainder -2   -7 div  3 = -2 remainder -1
    </pre>
    <p> Usage: <code>n' div d'</code> or <code>div(n', d')</code>
    @see Definition of integer division in Java Language Specification, Topic 15.17.2
 */
public static function IntegralElement div(IntegralElement n', IntegralElement d');
  given d' != 0;
  means forsome(IntegralElement remainder ::
      (     n'  =     return'  *     d'  +     remainder'
      & abs(n') = abs(return') * abs(d') + abs(remainder')
      & abs(remainder') < abs(d')
      )
    );

/**
    The remainder of whole division, designed for integer modulo operations, but allowed for all
    numbers. The system allows the <code>mod</code> operator to be used for any type that defines a
    <code>mod(n',d')</code> function; that is, <code>mod(n',d')</code> serves as the
    <code>mod</code> operator's backing definition.
   <p> Usage: <code>n' % d'</code> or <code>mod(n', d')</code>
   @see Definition of the remainder, % (Java Language Specification, Topic 15.17.3)
 */
public static IntegralElement mod(IntegralElement n', IntegralElement d');
  given d' != 0;
  means forsome(IntegralElement quotient' ::
      ( n' = quotient' * d' + return'
      & abs(n') = abs(quotient') * abs(d') + abs(return')
      & abs(return') < abs(d')
      )
    );

theorem  j'!=0  ==>  (i' div j')*j' + (i' % j') = i';

} // end interface IntegralElements