                                        // Copyright George S. Cowan, 2009. MIT open source license.
/** The mathematical integers, but restricted to an interval.
 *
 * No operation may have a result outside the interval. Therefore, every operation that returns a
 * BoundedInteger has an implicit given statement that checks that the result will be within the
 * interval and, if not, prevents the compiler from allowing the operation.
 *
 * We define methods that serve as a foundational definition of TrueJ integer operators.
 *
 * We use the Groovy function names for
 * overloading operators in an attempt to provide consistency across the field of programming.
 * TODO: Does TrueJ use operator overloading or does it just use phrases. This assumes operator
 *       overloading.
 */
public immutable interface BoundedInteger extends IntegralDomain phrase <Int> {

exemplars Int i', j', k', n';

phrase <0> means ZERO;

phrase <1> means ONE;

/** The minimum integer allowed for the implementation. Because a BoundedInteger is required to
 * contain zero, minxValue() <= 0. Each implementation defines a constant for
 * this value that is named MIN_VALUE for consistency. In a twos-complement
 * implementation, this will have a value of -2<sup>n</sup>; for instance, for the class Byte,
 * the value of n will be 8 so Byte.minValue() = Byte.MIN_VALUE = -128.
 */
public abstract static function Int minValue() phrase <m>;
  public axiom m <= 0;

/** The maximum integer allowed for the implementation. Because a BoundedInteger is required to
 * contain one, maxValue() >= 1. Each implementation defines a constant for
 * this value that is named MAX_VALUE for consistency. In a twos-complement
 * implementation, this will have a value of 2<sup>n</sup>-1; for instance, for the class Byte,
 * the value of n will be 8 so Byte.maxValue() = Byte.MAX_VALUE = 127.
 */
public abstract static function  Int maxValue() phase <M>;
  public axiom 1 <= M;

/** Note that the interval maximum and minimum restrictions on the results of operations means that
 * axioms and theorems do not have to worry about whether those results are truely BoundedIntegers. * However, no operation can be used unless it can be proven that its given statement is true.
 */
 IntegerBounds: axiom m <= i' <= M;

private theorem m <= 0 < 1 <= M;

/** Addition. The fact that it is a function establishes the uniqueness axiom for addition. There is no closure axiom because we do not require that m = -M, and we cannot if we wish to use BoundedInteger for defining 2's-complement implementations. The TrueJ compiler requires any method's given statement and code to establish its return value's type, and for the plus(a',b') method that means that it will need a given statement that requires:
    <pre><code>
        given m <= a' + b' <= M;
    </code></pre>
    but without using any subexpression that could be outside the bounds.

    Usage:
      <code>a' + b'</code> or <code>plus(a',b')</code>
 */
public abstract partialfunction Int plus(Int a');
  phrase <this' + a'>;
  given exists this' + a';

/**
    Is the result of an addition a valid BoundedInteger? We only have to
    evaluate the bounds because all sub-class implementations will already obey the other axioms. Therefore, we need to check
        <code> m <= a' + b' <= M </code>
    but without having any subexpressions that disobey the IntegerBounds axiom, because a' and b' may be numbers, not just symbols for the prover to manipulate. The expression that we use is also complicated by the need to remember that the prover will not return false for any check that it cannot prove, instead returning <code>unsupported</code> or <code>reachedLimit</code>. So for
       <code> a' >= 0 </code>
    the result may be either "true" (proven) or "who knows, try something else".

    We suspect that most of the time we will be adding positive numbers, so we attempt to check that condition first.

 */
private static condition sumExists(Int a', Int b') phrase <exists a' + b'>
    // show       m      <= a + b  <= M
    ( a' >= 0 & ( b' <= M - a' | b' <= 0 )
    | b' >= 0 & ( a' <= M - b' | a' <= 0 )
    | a' <= 0 &  m - a' <= b'
    | b' <= 0 &  m - b' <= a'
    );

/**
    We would like to prove that the sumExists(i',j') condition has no false positives or false negatives for addition, but the proof is trivial within the BoundedInteger's, so we prove it for the Integers.
 */
private static theorem
    forall(Integer min' : forall(Integer Max' :
      forall(Integer a' : min' <= a' <= Max' : forall(Integer b' : min' <= a' <= Max' :
          min' <= a'.plus(b') <= Max'
        ===
          ( a' >= Integer.zero() & ( b' <= Max' - a' | b' <= Integer.zero() )
          | b' >= Integer.zero() & ( a' <= Max' - b' | a' <= Integer.zero() )
          | a' <= Integer.zero() &  min' - a' <= b'
          | b' <= Integer.zero() &  min' - b' <= a'
          )
      ))
    ));

/**
    The expression in the definition of sumExists(i',j') is efficient, but it may be difficult to understand, so we show an equal and perhaps clearer expression that we <em>can</em> prove within the BoundedIntegers.
 */
private static theorem
    sumExists(a', b')
  ===
    ( // prohibit m <= a' + b'
      ( a' >= 0 & b' <= 0
      | a' <= 0 & b' >= 0
      | a' < 0  & m - a' <= b'
      | b' < 0  & m - b' <= a'
      )
    & // prohibit M < a' + b'
      ( a' >= 0 & b' <= 0
      | a' <= 0 & b' >= 0
      | a' > 0  & b' <= M - a'
      | b' > 0  & a' <= M - b'
      )
    );


/**************** WORKING HERE ***********************/

/**
  Equals can be added or subtracted to both sides of an equation. This subsumes both the axiom:
  uniqueness of addition, and the theorem: cancellation of addition, that occur in definitions of
  the integer domain. An axiom covering cancellation of addition is needed because its proof
  requires an axiom for the existence of an additive inverse, and we cannot count on that. For
  instance in 2's-complement implementations we do not always have an additive inverse because we do
  not have m = -M.
 */
UniquenessOfAddition:
  public axiom exists i' + k' ==> (i' = j' & k' = n'  ===  i' + k' = j' + n');

CancelationOfAddition:
  public theorem exists k' + i' & exists k' + j' ==>  (k' + i' = k' + j'  ===  i' = j');

/** Addition of integers is associative so there is no mathematical need to parenthesize a sequence
  * of additions.
  * <p>
  * Once this is established we can consider the operational order of additions. All subclasses,
  * treat addition as right-associative, so the expression <code>i' + j' + k</code> is operationally
  * eqivalent to<code>(i' + j') + k</code>. But because overflows are never allowed, that will give
  * the same result as <code>i' + (j' + k)</code>, so they are operationally eqivalent, too.
  */
AssociativityOfAdditon:
  public axiom exists i' + j' & exists j' + k'
               ==> (i' + j') + k' = i' + (j' + k') = i' + j' + k';

  private theorem  exists j' + k' & exists i' + j' & exists k' + n'
                   ==> i' + j' + k' + n' = i' + (j' + k') + n' = (i' + j') + (k' + n');

SymmetryOfAddition:
  public axiom exists i' + j' ==> (i' + j' = j' + i');

  private theorem  exists i' + j' & exists j' + k'
                   ==> i' + j' + k' = k' + j' + i';

AdditiveIdentity:
  axiom i' + 0 = i';
  public theorem  0 + i' = i';

/**
    Multiplication. The <code> multiply(a',b') </code> function is the backing definition of the
    TrueJ <code> * </code> operator. It is kept in sync but it is not used for implementation, other than that it tells the compiler about the given statement that is to be used before any use of the <code> * </code> operator. The fact that it is a function establishes the uniqueness axiom for multiplication. There is no closure axiom because the product of many BoundedIntegers would fall outside the bounds. The TrueJ compiler requires any method's given statement and code to establish its return value's type, and for the multiply(a',b') function that means that it will need a given statement that requires:
    <pre><code>
        given m <= a' * b' <= M;
    </code></pre>
    but without using any subexpression that could be outside the bounds.

    <p> Usage:
      <code>a' * b'</code> or <code>multiply(a',b')</code>
 */
public abstract static function Int multiply(Int a', Int b');
  phrase <a' * b'>;
  given exists a' * b';

/**
    Is the result of a multiplication a valid BoundedInteger. Establish whether
    <code> m <= a' * b' <= M but without having any subexpressions that disobey the IntegerBounds
    axiom. We do not have to evaluate any of the other axioms because all sub-class implementations
    will already have them.
 */
private static condition productExists(Int a', Int b') phrase <exists a' * b'>
  ( // prohibit a' * b' < minValue()
    ( a' = 0 | a' = 1 | b' = 0 | b' = 1
    | sign(a') = sign(b') // thus m <= 0 <= a' * b'
    | a' < 0 & m div a' <= b'
    | b' < 0 & m div b' <= a'
    )
  & // prohibit maxValue() < a' * b'
    ( a' = 0 | a' = 1 | b' = 0 | b' = 1
    | sign(a') != sign(b')
    | a' > 0  & b' <= M div a'
    | b' > 0  & a' <= M div b'
    )
  )

/**
    Identical values result in identical products. Or you can think of it as equals can multiply
    both sides of an equation.

    TODO: compare to UniquenessOfAddition
 */
UniquenessOfMultiplication:
  public axiom exists i' * k' & i' = j' & k' = n'  ==>  i' * k' = j' * n';

AssociativityOfMultiplication:
  public axiom exists i' * j' & exists j' * k'  ==>  (i' * j') * k' = i' * (j' * k');

SymmetryOfMultiplication:
  public axiom exists i' * j'  ==>  i' * j' = j' * i';

MultiplicativeIdentity:
  public axiom   i' * 1  = i';
  public theorem 1  * i' = i';

/**
  Multiplication * is stickier than addition + so parentheses can be omitted when adding products, though not when multiplying sums.
 */
DistributionOfMultiplicationOverAddition:
  public axiom exists j' + k' & exists i'*j' & exists i'*k'  ==>  i' * (j' + k') = i'*j' + i'*k';
  public theorem exists j' + k' & exists j'*i' & exists k'*i'  ==>  (j' + k') * i' = j'*i' + k'*i';

CancelationOfMultiplication:
  public axiom   exists k' * i' & exists k' * j'
                 ==>  k' != 0  ==> ( k' * i' = k' * j'  ===  i' = j' );

  public theorem exists i' * k' & exists j' * k'
                 ==>  k' != 0  ==> ( i' * k' = j' * k'  ===  i' = j' );

/** Every member of the BoundedInteger has a negative(), with the exception of m. The
 * system uses the prefix operator <code> - </code> for this in each integer implementation. We
 * include a phrase for the operator so that when we use an expression like <code> -a </code>
 * here in the definition of BoundedInteger, we are referring to the method
 * negative(a) and not any particular implementation's prefix <code> - </code> operator.
   <p> Usage: <code> -a'</code> or <code>negative(a')</code>
 */
public abstract static Int negative(Int a') private phrase < - a'>;
  // if abs(m) <= M then all negatives, and positives up to abs(m), are OK
  // if abs(m) >  M then all positives, and negatives down to -M, are OK
  given exists -a';
  means  a' + negative(a') = 0;

private condition negativeExists(Int a') phrase <exists - a'>
  ( m + M >= 0 & (a' <= 0 | m + a' <= 0)
  | m + M <  0 & (a' >= 0 | M + a' >= 0)
  );

/** Subtraction is the minus(a,b) method. This is a method corresponding to the implemented
 * subtraction operation for each subclass. The system maps subtraction to the binary
 * operator <code> - </code> for each subclass implementation, but those are not available to us
 * in this abstract superclass. To make the code readable, we provide a phrase that lets us
 * refer to the minus() method here in the definition of BoundedInteger with <code> - </code>.
 * <p>
 * Usage: <code>a' - b'</code> or <code>minus(a',b')</code> */
public abstract static  Int minus(Int a', Int b') private phrase <a' - b'>;
  given exists a' - b';
  means return = a' + -b';

/**
    Is the result of an subtraction a valid BoundedInteger? Establish whether
        <code> m <= a' - b' <= M
    but without having any subexpressions that disobey the IntegerBounds axiom. We test for equal signs to eliminate  Note that
       a',-b' both >= 0 means a' - b' >= 0 >= m
    therefore we only need to test the case b' > 0 to ensure that m <= a' - b'. And note that
       a',-b' both <= 0 means a' - b' <= 0 <= M
    therefore we only need dto test the case bWe do not have to evaluate any of the other axioms because all sub-class implementations will already have them.
 */
private condition minusExists(Int a', Int b') phrase <exists a' - b'>
  ( // m <= a - b
    (
      b >= 0 & m + b <= a
    |
      b < 0 & exists -m & b <= a + -m
    |
      b <= 0 & a < 0 &
    )
  &
  )

  ( // prohibit m <= a' + b'
    ( a' >= 0 & b' >= 0
    | a' < 0  & m - a' <= b'
    | b' < 0  & m - b' <= b'
    )
  & // prohibit M < a' + b'
    ( a' <= 0 & b' <= 0
    | a' > 0  & b' <= M - a'
    | b' > 0  & a' <= M - b'
    )
  );

  ( a' >0 0 & 0 <= b' <= a & m <= a - b <= M
  | a' < 0 & b' < 0 // the clearly m <= a' - b' <= M
  | ( b' > 0  & m + b' <= a'
      // thus   m      <= a' - b'
    & b' <  0 & a'      <= M + b'
      // thus   a' - b' <= M

      | b < 0 & a > 0 & a > M + b & b > m+M      & a - b <= M           b > m+M
                                   a - m - M <= M


    )
  );

      ?????  NEED TO USE EXAMPLES, e.g,  m = -5, a = 3, b = -2, M = 4
      | b' <  0  & exists -b  & m +
      | b' <  0  & exists -m  &           b' <= a' + -m // abs(m) <= M
      | b' <  0  & exists -M  & m + M + b'  <= a' + -m + m + M
      ?????
      )
    & // prohibit M < a' - b', so a' - b' <= M
    )
  );
  // -b exists and
  ( // prohibit a' - b' < m, therefore m <= a' - b'
    ( signum(a') = signum(b')
    | b' >= 0               & m + b' <= a'

                            & m         <= a - b
                            & m + M     <= a - b + M
                            & m + M - a <= M - b
                            & -(m+M)+a  >= b - M
                            & a - m     >= b
    | b' < 0  & 0 <= m + M  &     b' <= a' + -m // abs(m) <= M
    )
  & // prohibit M < a' - b', so a' - b' <= M
    ( signum(a') != signum(b')
    | a' > 0  & b' <= M - a'
    | b' > 0  & a' <= M - b'
    )
  );

/* This is a theorem if we have the Well-ordering Principle as an axiom. */
public axiom i' > 0  ==> i' >= 1;

private theorem  ~(0 < i' < 1);

/** BoundedInteger division, which leaves a remainder. We map the div(n,d) method to the
 * <code>div</code> operator, saving the operator / for division that does not leave a remainder,
 * as in rational number division.
 * <p> Usage: n div d or div(n,d)
 * @see Definition of integer division in Java Language Specification, Topic 15.17.2 */
public abstract static  Int div(Int n', Int d') private phrase <n' div d'>;
  given d' != 0 & !(n' = m & d' = -1);
  means forsome Int remainder
      ( n' = return' * d' + remainder'
      &   (sameSignLax(n',d') ==> 0 <= remainder < d')
      & ! (sameSignLax(n',d') ==> 0 >= remainder > d')
      );

/** The remainder of integer division, We map the mod() method to the operator <code> % </code>.
   <p> Usage: a % b or mod(a,b)
   @see Definition of the remainder, % (Java Language Specification, Topic 15.17.3)
   @see intdiv */
public abstract static  Int mod(Int a, Int b) private phrase <a % b>;
  given b != 0;
  means forsome Int quotient
      ( a = quotient * b + return
      &   (sameSignLax(a,b) ==> 0 <= return < b)
      & ! (sameSignLax(a,b) ==> 0 >= return > b)
  ;

/** Do the parameters have the same sign? Returns true if either is zero. */
public abstract static boolean sameSignLax(Int a, Int b) {
  if (a>=0)
    return = b>=0;
  else
    return = b<=0;
  }
  means a>=0 ==> return = b>=0
      & a<0  ==> return = b<=0;
    /*  or return = (a>=0) ? b>=0 : b<=0; */

theorem  (i div j)*j + (i % j) = i;

/** Integer division with a remainder. We provide for computing the quotient and remainder in a
   single operation.
   @see div()
   @see mod() */
public abstract static  Int intDiv(Int dividend', Int divisor', Int 'quotient, Int 'remainder);
  given divisor' != 0
      & !(dividend' = m & divisor' = -1);
  means dividend div divisor = quotient
      & dividend  %  divisor = remainder
  ;

// ******************************
// *** Consistency components ***
// ******************************
public String toString();

public abstract static  equals(Object other'); // Leave type of o as Object
  means this' = other' ==>  return = true                // Reflexive
      & return = other'.equals(this')                    // Symmetric
      & i'.equals(j') & j'.equals(k') ==> i'.equals(k'); // Transitive
      // therefore equals() is an equivalence relation

public abstract static int hashCode();
  means equals(i') ==> return = i'.hashCode();


public abstract static int compareTo(Name other);
//{
//// required for Comparable objects
////
//  if      (this.a < other.a)    { return -1; }
//  else if (this.equals(other))  { return  0; }
//  else                          { return +1; }
//}

public abstract static Object clone();
//{ // shallow copy
//  return new Name(a);
//}

} // end class Name
