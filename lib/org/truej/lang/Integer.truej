/** The 32-bit integers with a range from -2e31 to +2e31-1. Computations are checked by the compiler
   to prevent programs from ever computing a number outside this range. This means many methods
   will require a <code>given</code>-statement specifying a range for the method parameters so that
   all computations in the method can be proven to compute without an overflow. */
public class
Integer implements Cloneable, Comparable
  phrase <Int> {

exemplar Int n', i', j', k';

/** Zero is a Integer. The numeral <code>0</code> is a synonym for <code>ZERO</code>. */
public static Int ZERO
  phrase <0>;

/** One is a Integer. The numeral <code>1</code> is a synonym for <code>ONE</code>. */
public static Int ONE
  phrase <1>;

/** Addition is the plus(a,b) method, which the system maps to the operator <code> + </code>.
   <p> Usage: a + b or plus(b,b) */
public static Int plus(Int a', Int b')
  phrase <a' + b'>;

AssociativityOfAdditon: axiom (i' + j') + k' = i' + (j' + k');

SymmetryOfAddition: axiom i' + j' = j' + i';

AdditiveIdentity: axiom n' + 0 = n';

/** Multiplication is the multiply(a,b) method, which the system maps to the operator <code> * </code>.
   <p> Usage: a + b or multiply(a,b) */
public static Int multiply(Int a', Int b') phrase <a' * b'>;

/** Subtraction is the minus(a,b) method, which the system maps to the operator <code> - </code>.
   <p> Usage: a - b or minus(a,b) */
public static Int minus(Int a', Int b') phrase <a' - b'>;

/** Integer division, which leaves a remainder. We map the div(n,d) method to the <code>div</code>
   operator, saving the operator / for division that does not leave a remainder, as in rational
   number division.
   <p> Usage: n div d or div(n,d)
   @see Definition of integer division in Java Language Specification, Topic 15.17.2 */
public static Int div(Int n', Int d') phrase <n' div d'>;
  given d' != 0;
  means forsome Int remainder
      ( n' = return' * d' + remainder'
      &   (sameSignLax(n',d') ==> 0 <= remainder < d')
      & ! (sameSignLax(n',d') ==> 0 >= remainder > d')
      );

/** The remainder of integer division, We map the mod() method to the operator <code> % </code>.
   <p> Usage: a % b or mod(a,b)
   @see Definition of the remainder, % (Java Language Specification, Topic 15.17.3)
   @see intdiv */
public static Int mod(Int a, Int b) phrase <a % b>;
  given b != 0;
  means forsome Int quotient
      ( a = quotient * b + return
      &   (sameSignLax(a,b) ==> 0 <= return < b)
      & ! (sameSignLax(a,b) ==> 0 >= return > b)
  ;

/** Do the parameters have the same sign? Returns true if either is zero. */
private static boolean sameSignLax(I a, I b);
  means return = (a>=0) ? b>=0 : b<=0;

theorem  j!=0  ==>  (i div j)*j + (i % j) = i;

/** Integer division with a remainder. We provide for computing the quotient and remainder in a
   single operation.
   @see div()
   @see mod() */
static public Int intDiv(Int dividend', Int divisor',
                                 Int 'quotient, Int 'remainder);
  means dividend div divisor = quotient
      & dividend  %  divisor = remainder
  ;

// ********************
// *** Constructors ***
// ********************
public Int() {
  // if there is a reasonable default for every field, you can create a default constructor
}

public Int(Int a) {
  this.a = new TYPEAAA(a); // copy constructor should create a deep copy
}

// ******************************
// *** Consistency components ***
// ******************************
public String toString() {
  return (a.toString);
}

public boolean equals(Object other) { // Leave type of o as Object
  /* Defines an Equivalence relation
     Reflexive:  a.equals(a) must return true.
     Symmetric:  If a.equals(o) then o.equals(a) as well (usually the difficult one).
     Transitive: If a.equals(b) and b.equals(c), then a.equals(c).

  */
  if      (other == null)                  { return false; }
  else if (getClass() != other.getClass()) { return false; }
  else {
    return (this.a.equals(other.a));
  }
}

public int hashCode() {
  // Consistent with equals: two "equals" objects should have same hashCode result.
  return hashCode(a);
}

public int compareTo(Name other) {
// required for Comparable objects
//
  if      (this.a < other.a)    { return -1; }
  else if (this.equals(other))  { return  0; }
  else                          { return +1; }
}

public Object clone() { // shallow copy
  return new Name(a);
}

public Name deepCopy {
  return new Name(new Int(a));
}

} // end class Name