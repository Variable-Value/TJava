/** The integers modulo some number, but with half the range as negative numbers, like the 32 bit
   Java <code>int</code> type. Addition will make these numbers wrap around from high positives to
   low negatives. Because these are modulo types and may wrap around on many operations, their
   magnitude is not checked by the compiler after calculations, and magnitude comparisons, such as
   <, <=, >=, or >, may not be provable.
   <p>
   Note that in TrueJ the class and primitive names, Byte (byte), Short (short), Integer (int), and
   Long (long), are not used for modulo types and behave more like integers with a compiler checked
   range; if you want modulo behavior, you must use the ModuloNegative subtypes and the primitive
   names with the <code>modulo</code> modifier: ByteModulo (modulo byte), ShortModulo
   (modulo short), IntegerMod (modulo int), and LongModulo (modulo long) that correspond to the Java
   classes and primitives Byte (byte), Short (short), Integer (int), and Long (long).
   @see Number */
public class
ModuloNegative implements Cloneable, Comparable
  phrase <ModN> {

exemplar ModN n', i', j', k';

/** Zero is a ModuloNegative. The numeral <code>0</code> is a synonym for <code>ZERO</code>. This
   does not need to be redeclared in each subtype; they all use "the same" ZERO as though it were an
   inherited function. */
public static ModN ZERO
  phrase <0>;

/** One is a ModuloNegative. The numeral <code>1</code> is a synonym for <code>ONE</code>. This
   does not need to be redeclared in each subtype; they all use "the same" ONE as though it were an
   inherited function. */
public static ModN ONE
  phrase <1>;

/** Addition is the plus(a,b) method, which the system maps to the operator <code> + </code>.
   <p> Usage: a + b or plus(b,b) */
public static ModN plus(ModN a', ModN b')
  phrase <a' + b'>;

AssociativityOfAdditon: axiom (i' + j') + k' = i' + (j' + k');

SymmetryOfAddition: axiom i' + j' = j' + i';

AdditiveIdentity: axiom n' + 0 = n';

/** Multiplication is the multiply(a,b) method, which the system maps to the operator
   <code> * </code>.
   <p> Usage: a + b or multiply(a,b) */
public static ModN multiply(ModN a', ModN b') phrase <a' * b'>;

/** Subtraction is the minus(a,b) method, which the system maps to the operator <code> - </code>.
   <p> Usage: a - b or minus(a,b) */
public static ModN minus(ModN a', ModN b') phrase <a' - b'>;

/** Integer division, which leaves a remainder. We map the div(n,d) method to the <code>div</code>
   operator, saving the operator / for division that does not leave a remainder, as in rational
   number division.
   <p> Usage: n div d or div(n,d)
   @see Definition of integer division in Java Language Specification, Topic 15.17.2 */
public static ModN div(ModN n', ModN d') phrase <n' div d'>;
  given d' != 0;
  means forsome ModN remainder
      ( n' = return' * d' + remainder'
      &   (sameSignLax(n',d') ==> 0 <= remainder < d')
      & ! (sameSignLax(n',d') ==> 0 >= remainder > d')
      );

/** The remainder of integer division, We map the mod() method to the operator <code> % </code>.
   <p> Usage: a % b or mod(a,b)
   @see Definition of the remainder, % (Java Language Specification, Topic 15.17.3)
   @see intdiv */
public static ModN mod(ModN a, ModN b) phrase <a % b>;
  given b != 0;
  means forsome ModN quotient
      ( a = quotient * b + return
      &   (sameSignLax(a,b) ==> 0 <= return < b)
      & ! (sameSignLax(a,b) ==> 0 >= return > b)
  ;

/** Do the parameters have the same sign? Returns true if either is zero. */
private static boolean sameSignLax(I a, I b);
  means return = (a>=0) ? b>=0 : b<=0;

theorem  j!=0  ==>  (i div j)*j + (i % j) = i;

/** Integer division with a remainder. We provide for computing the quotient and remainder in a
   single operation.
   @see div()
   @see mod() */
static public ModN intDiv(ModN dividend', ModN divisor',
                                 ModN 'quotient, ModN 'remainder);
  means dividend div divisor = quotient
      & dividend  %  divisor = remainder
  ;

// ********************
// *** Constructors ***
// ********************
public ModN() {
  // if there is a reasonable default for every field, you can create a default constructor
}

public ModN(ModN a) {
  this.a = new TYPEAAA(a); // copy constructor should create a deep copy
}

// ******************************
// *** Consistency components ***
// ******************************
public String toString() {
  return (a.toString);
}

public boolean equals(Object other) { // Leave type of o as Object
  /* Defines an Equivalence relation
     Reflexive:  a.equals(a) must return true.
     Symmetric:  If a.equals(o) then o.equals(a) as well (usually the difficult one).
     Transitive: If a.equals(b) and b.equals(c), then a.equals(c).

  */
  if      (other == null)                  { return false; }
  else if (getClass() != other.getClass()) { return false; }
  else {
    return (this.a.equals(other.a));
  }
}

public int hashCode() {
  // Consistent with equals: two "equals" objects should have same hashCode result.
  return hashCode(a);
}

public int compareTo(Name other) {
// required for Comparable objects
//
  if      (this.a < other.a)    { return -1; }
  else if (this.equals(other))  { return  0; }
  else                          { return +1; }
}

public Object clone() { // shallow copy
  return new Name(a);
}

public Name deepCopy {
  return new Name(new ModN(a));
}

} // end class Name