                                        // Copyright George S. Cowan, 2019. MIT open source license.
/**
    The mathematical integers. We use the name IntegralDomain here and reserve the name Integer for
    32-bit 2s-complement integers in order to stay parallel to Java. Because integers have no upper
    and lower limits, they are technically uncomputable; however an almost complete implementation
    could be made that only represented the integers needed for a particular computation.
 */
public immutable abstract class IntegralDomain implements Comparable phrase <Int> {
exemplar  Int n', i', j', k';

/** Zero is an integer. The numeral <code>0</code> is a synonym. */
public static total function Int zero()
  phrase <0>;

/** One is an integer. The numeral <code>1</code> is a synonym. */
public static total function Int one()
  phrase <1>;

axiom 1 != 0;

/**
  Addition of integers is the <code> plus(addend') </code> method.
  <p>
  The fact that it is a function establishes the uniqueness axiom for addition, the sum being a
  function of <code>this</code> and the <code>addend</code>. If <code>plus(addend')</code> were not
  marked with the <code>function</code> modifier, then we could not count on it being determined by
  the values of <code>this</code> and <code>addend</code>, and TrueJ would require us to code a new
  and unique decoration for <code>this</code> or <code>addend</code> every time we added them. This
  is TrueJ's way of enforcing the higher level Leibnitz axiom, "Equals can always be substituted for
  equals". For example, <code>Math'.random()</code> always requires a unique decoration on
  <code>Math</code> to show that its result is not determinate and to help us see that the values
  are different.
  <p>
  The fact that it is a total function establishes the closure axiom for addition. The
  <code>total</code> modifier prevents any implementation from having given statements or runtime
  exceptions, ensuring the existence of the result for all but catastrophic circumstances.
  <p>
  To establish that plus(addend') is injective, we will provide a cancellation theorem.
  <p>
  The system allows the <code> + </code> operator to be used for any type that defines a
  <code>plus(x')</code> function, which serves as the operator's backing definition.
  <p>
  Usage: <code>a' + b'</code> or <code> a'.plus(b') </code>
 */
public total function Int plus(Int addend');

/**
  Functional form of Uniqueness of addition. Because <code>this'.plus(addend')</code> is a function,
  the system has already made the following statement an axiom; it corresponds to the Uniqueness
  Axiom for addition. By coding it here as a private theorem , we are verifying that it was implicitly
  implemented by the system. (A function is not allowed to have a side-effect and its result is
  determinate.) The prover uses the Leibnitz rule to prove the theorem.
 */
FunctionPlus: private theorem  i' = j'  ==>  this'.plus(i') = this'.plus(j');

/**
  Uniqueness of addition. Equals can be added to or subtracted from both sides of an equation.
  <p>
  We restate the Uniqueness Axiom in its more usual form with the easier to read <code>+</code>
  operator. In actuality, the TrueJ system always obeys the Leibnitz axiom, "Equals can always be
  substituted for equals".
 */
UniquenessOfAddition: theorem i' = j' & k' = n'  ==>  i' + k' = j' + n';

AssociativityOfAddition: axiom (i' + j') + k' = i' + (j' + k');

SymmetryOfAddition: axiom i' + j' = j' + i';

AdditiveIdentity: axiom n' + 0 = n';

UniquenessOfAdditiveIdentity: theorem i' + j' = i'  ===  j' = 0;
  (because i' + j' = i'
         = i' + j' = i' + 0 (because of AdditiveIdentity)
         =      j' =      0 (because of CancelationOfAddition)
  )

/**
  Additive Inverse. Every integer has a corresponding additive inverse, its negation. We will show
  in a theorem that <code>0.negative() = 0</code>.
  <p>
  The fact that it is a function establishes the uniqueness axiom for the negation. If
  <code>negative()</code> were not marked with the <code>function</code> modifier, then we could not
  count on it being determined by the value of <code>this</code>, and TrueJ would require us to code
  a new and unique decoration for <code>this</code> every time we negated it. This is TrueJ's way of
  enforcing the higher level Leibnitz axiom, "Equals can always be substituted for equals".
  <p>
  The fact that it is a total function establishes the closure axiom for negation; the negation
  always exists. The <code>total</code> modifier prevents any implementation from having
  <code>given</code> statements or runtime exceptions, ensuring the existence of the result for all
  but catastrophic circumstances.
  <p>
  The system allows the unary <code>-</code> operator to be used for any type that defines a
  <code>negative()</code> function, which serves as the operator's backing definition.
  <p>
  Usage: <code>-a'</code> or <code> a'.negative() </code>
 */
public total function Int negative();
means this' + result' = 0;

/**
  The unary minus can be used for the additive inverse of an Int.
 */
AdditiveInverse: theorem k' + -k' = 0;

/** Cancellation Theorem for addition. Equal sums allow cancellation of equal addends. */
CancellationOfAddition: theorem k' + i' = k' + j'  ===  i' = j'
  (because        k' + i'  =        k' + j'
       ==>  -k + (k' + i') =  -k + (k' + j') (because of UniquenessOfAddition)
       === (-k + k') + i'  = (-k + k') + j'  (because of AssociativityOfAddition)
       ===         0 + i'  =         0 + j'  (because of AdditiveInverse)
       ===             i'  =             j'  (because of AdditiveIdentity)
  );
// Alternatively,
//  (because 1. k' + i' = k' + j'  ==>  i' = j' (because
//           1.1 assuming k' + i' = k' + j';
//           1.2.            i'
//              = 0        + i' (because of AdditiveIdentity)
//              = -k' + k' + i' (because of AdditiveInverse)
//              = -k' + k' + j' (because of 1.1. & SubstitutionOfEquals)
//              = 0        + j' (because of AdditiveInverse)
//              =            j' (because of AdditiveIdentity)
//           );
//           2. k' + i' = k' + j' <== i' = j' (because
//           2.1. assuming i' = j';
//           2.2. k' + i'
//              = k' + j' (because of SubstitutionOfEquals)
//           );
//           7. k' + i' = k' + j'  ===  i' = j' (because of 1., 2.);
//           QED
//  );

/**
  Multiplication of integers is the <code>multiply(multiplier')</code> method.
  <p>
  The fact that it is a function establishes the uniqueness axiom for multiplication, the product
  being a function of <code>this</code> and the <code>multiplier</code>. If
  <code>multiply(multiplier')</code> were not marked with the <code>function</code> modifier, then
  we could not count on it being determined by the values of <code>this</code> and
  <code>multiplier</code>, and TrueJ would require us to code a new and unique decoration for
  <code>this</code> or <code>multiplier</code> every time we multiplied them. This is TrueJ's way of
  enforcing the higher level Leibnitz axiom, "Equals can always be substituted for equals".
  <p>
  The fact that it is a total function establishes the closure axiom for multiplication. The
  <code>total</code> modifier prevents any implementation from having given statements or runtime
  exceptions, ensuring the existence of the result for all but catastrophic circumstances.
  <p>
  To establish that <code>multiply(multiplier')</code> is injective, we will provide a cancellation
  axiom.
  <p>
  The system allows the
  <code>*</code> operator to be used for any type that defines a <code>multiply(x')</code> function,
  which serves as the operator's backing definition. The <code>*</code> operator binds tighter than
  <code>+</code>, so <code>i' * j' + n' = (i' * j') + n'</code>.
  <p>
  Usage: a' * b' or a'.multiply(b)
 */
public total function Int multiply(Int multiplier') phrase <a' * b'>;

/**
  Functional form of Uniqueness of multiplication. Because <code>multiply(multiplier')</code> is a
  function, the system has already made the following statement an axiom; it corresponds to the
  Uniqueness Axiom for multiplication. By coding it here as a theorem, we are verifying that it was
  implicitly implemented by the system. (A function is not allowed to have a side-effect and its
  result is determinate.)
 */
FunctionMultiply: private theorem  i' = j'  ==>  this'.multiply(i') = this'.multiply(j');

/**
  Uniqueness of multiplication. Equals can multiply both sides of an equation.
  <p>
  We restate the Uniqueness Axiom in its more usual form with the easier to read <code>*</code>
  operator. In actuality, the TrueJ system always obeys the Leibnitz axiom, "Equals can always be
  substituted for equals".
 */
UniquenessOfMultiplication:
  theorem i' = j' & k' = n'  ==>  i' * k' = j' * n'
    (because i' = j' &      k' =      n'
         ==> i' = j' & i' * k' = i' * n' (because of FunctionMultiply)
         ==>           i' * k' = j' * n' (because of Leibnitz)
    );

AssociativityOfMultiplication: axiom (i' * j') * k' = i' * (j' * k');

SymmetryOfMultiplication: axiom i' * j' = j' * i';

MultiplicativeIdentity: axiom n' * 1 = n';

MultiplicationDistributesOverAddition: axiom n' * (i' + j') = n'*i' + n'*j';

/**
  Cancellation Axiom for multiplication. Equal products allow cancellation of equal multipliers.
  This must be an axiom instead of a theorem because we do not have a guaranteed inverse for
  multiplication in the integers.
 */
CancelationOfMultiplication: axiom k' != 0  ==>  (k' * i' = k' * j'  ===  i' = j');

/**
  Zero theorem for multiplication.
 */
Zero: theorem n' * 0 = 0
  (because true
       === n'*n'         = n'*n'
       === n'*(n' + 0)   = n'*n' + 0 (because of AdditiveIdentity)
       === n'*n'  + n'*0 = n'*n' + 0 (because of DistributionOfMultiplicationOverAddition)
       ===          n'*0 =         0 (because of CancellationOfAddition)
  );

ZeroProduct: theorem i'*j' = 0  ===  i' = 0 | j' = 0
  (because i'    = 0    | j'    =    0
       === i'*j' = 0*j' | i'*j' = i'*0 (because of Zero)
       === i'*j' = 0    | i'*j' =    0 (because of Zero)
       === i'*j' = 0
  );

/**
  <code>i'+n'=0</code> means that <code>i'=-n'</code>, and there is only one additive inverse for
  <code>n'</code>.
 */
UniqueAdditiveInverse: i' + n' = 0 & j' + n' = 0  ==>  i' = j'
  (because i' + n' = 0 & j' + n' = 0
       ==> i' + n'     = j' + n'
       === i'          = j'      (because of CancellationOfAddition)
  );

/**
  Subtraction of integers is the <code>minus(subtrahend')</code> method. This Int is the minuend,
  from which the subtrahend is subtracted.
  <p>
  The fact that it is a function establishes the uniqueness axiom for subtraction, the result being a
  function of <code>this</code> and the <code>subtrahend</code>. If <code>minus(subtrahend')</code>
  were not
  marked with the <code>function</code> modifier, then we could not count on it being determined by
  the values of <code>this</code> and <code>subtrahend</code>, and TrueJ would require us to code a new
  and unique decoration for <code>this</code> or <code>subtrahend</code> every time we added them. This
  is TrueJ's way of enforcing the higher level Leibnitz axiom, "Equals can always be substituted for
  equals".
  <p>
  The fact that it is a total function establishes the closure axiom for subtraction. The
  <code>total</code> modifier prevents any implementation from having given statements or runtime
  exceptions, ensuring the existence of the result for all but catastrophic circumstances.
  <p>
  To establish that minus(subtrahend') is injective, we will provide a cancellation theorem.
  <p>
  The system allows the <code>-</code> operator to be used for any type that defines a
  <code>minus(x')</code> function, which serves as the operator's backing definition.
  <p>
  Usage: <code>a' - b'</code> or <code> a'.minus(b') </code>
  Usage: a - b or minus(a,b)
  */
public total function Int minus(Int subtrahend');
means result' = this' + -subtrahend';

Subtraction: theorem i' - j' = i' + -j';

GS_15_15: theorem i' + n' = 0  ===  i' = -n';
GS_15_16: theorem -i' = -j'  ===  i' = j';
GS_15_17: theorem -(-n') = n';
GS_15_18: theorem -0 = 0;
GS_15_19: theorem -(i' + j') = -i' + -j';
GS_15_20: theorem -n' = -1 * n';
GS_15_21: theorem -i' * j' = i' * -j';
GS_15_22: theorem i' * -j' = -(i'*j');
GS_15_23: theorem -i' * -j' = i'*j';
GS_15_24: theorem n' - 0 = n';
GS_15_25: theorem (i' - j') + (k' - n') = (i' + k') - (j' + n');
GS_15_26: theorem (i' - j') - (k' - n') = (i' + n') - (j' + k');
GS_15_27: theorem (i' - j')*(k' - n') = (i'*k' + j'*n') - (i'*n' + j'*k');
GS_15_28: theorem i' - j' = k' - n'  ===  i' + n' = j' + k';
GS_15_29: theorem (i' - j')*k' = i'*k' - j'*k';

/**
  We use the notion of positive integers to formalize the Integral Domain as an Ordered Domain,
  following G&S, p. 307.
 */
public total function boolean positive() {
  return this'.compareTo(0) > 0;
};

AdditionOfPositives:       axiom i'.positive() & j'.positive()  ==>  (i' + j').positive();
MultiplicationOfPositives: axiom i'.positive() & j'.positive()  ==>  (i'*j').positive();
ZeroIsNotPositive:         axiom ! 0.positive();
NegativeIsNotPositive:     axiom i'!=0  ==>  (i'.positive()  ===  ! (-i').positive();

GS_15_34: theorem n'!=0  ==>  (n'*n').positive()
  (given   1. n'!=0
   because 2. n'.positive() | ! n'.positive() (because 1.)
           3. for (n'*n').positive();

           3.1. case n'.positive();
           3.1.1. (n'*n').positive() (because of MultiplicationOfPositives);

           3.2. case ! n'.positive();
           3.2.1.   n'.positive() === ! (-n').positive() (because 1., NegativeIsNotPositive);
           3.2.2. ! n'.positive() ===   (-n').positive();
           3.2.3.                       (-n').positive() (because 3.2., 3.2.2.);
           3.2.4. (-n').positive() & (-n').positive();
           3.2.5. (-n'*-n').positive() (because of MultiplicationOfPositives);
           3.2.6. ( n'* n').positive() (because -i' * -j' = i'*j')

           4. (n'*n').positive() (because 3.);
           QED
  );

GS_15_35: theorem i'.positive()  ==>  (j'.positive()  ===  (i'*j').positive());

theorem 1.positive()
  (because 1. 1 != 0;
           2. (1*1).positive() (because n'!=0  ==>  (n'*n').positive());
           3. 1*1 = 1 (because 1*n' = n');
           4. 1.positive();
  );

theorem ! (-1).positive();

/**
    Defines an Equivalence relation; that is, it is reflexive, symmetric, and transitive. Equality
    also obeys the Leibniz rule: "Two expressions are equal in all states iff replacing one by the
    other in any expression E does not change the value of E (in any state)" (G&S, p. 12). This
    cannot be stated as a first order theorem but we can verify that the prover supports this for
    specific expressions.

    Since equality is reflexive and either of the two equal objects can be substituted for the other
    in any expression, then we have the corollary that two equal objects must have exactly the same
    type or be automatically converted.

    TODO: This will require some special thought with numeric types, e.g., <code>1 = 1.0</code>. Is
          promotion of integer types sufficient? The only problem that I can see at a glance is in
          assignments (<code>int a = 1;</code> vs. <code>int a = 1.0</code>) and method arguments
          (<code>anInteger.plus(1)</code> vs. <code>anInteger.plus(1.0)</code>). It may be that we
          must syntactically prohibit certain automatic casting and require proof that a narrowing
          conversion will avoid an Exception. (Refer to spec, Chapter 5.)

    If two objects may have different classes, e.g., one is be a subtype of the other, or both are
    referenced from a supertype variable where it is only the supertype characteristics that are
    relevant, then the programmer may want to explicitly force them to the same type, e.g.,
    <code>(Circle)graphicArray[0] = currentCircle</code>.

    A check for parameter <code>other'</code> being null is not required because the parameter is
    not optional.

    The .equals(other') function serves as the backing function for the operators = and ===, the
    only difference being that = is syntactically stickier than ===. Note that both are conjunctive,
    unlike the equivalence operator in G&S (p. 29).
 */
public total function boolean equals(Object other');

EqualityIsReflexive:  private theorem n' = n';
EqualityIsSymmetric:  private theorem i' = j'  ===  j' = i';
EqualityIsTransitive: private theorem i' = j' & j' = k'  ==>  i' = k';

/**
  The compareTo(other') function is the basis for less than and greater-than, and is synchronized
  with equality.
  <p>
  The system automatically uses compareTo as the backing function for the ordering relations:
  <pre>
    <  is mapped to a result of -1
    <= is mapped to a result of -1 or 0
    =  is mapped to this'.equals(other') but that must be equivalent to a result of 0
    >= is mapped to a result of +1 or 0
    <  is mapped to a result of +1
  </pre>
  <p>
  @result +1 if this' > other',
           0 if this' = other',
          -1 if this' < other'
 */
public total function Int compareTo(Name other);
  means i'.equals(j')  ===  i'.compareTo(j') = 0
      & i'.positive()  ===  i'.compareTo(j') = 1
      & ( i'.compareTo('j) = -1
        | i'.compareTo('j) =  0
        | i'.compareTo('j) =  1
        );

LessThan:    theorem i' <  j'  ===  (j' - i').positive();
GreaterThan: theorem i' >  j'  ===  (i' - j').positive();
AtMost:      theorem i' <= j'  ===  i' < j' | i' = j';
AtLeast:     theorem i' >= j'  ===  i' > j' | i' = j';

Positives: theorem i'.positive()  ===  0 < i';
Transitivity: theorem i' <  j' & j' <  k'  ==>  i' <  k'
                    & i' <= j' & j' <  k'  ==>  i' <  k'
                    & i' <  j' & j' <= k'  ==>  i' <  k'
                    & i' <= j' & j' <= k'  ==>  i' <= k';
MonotonicityOfAddition: theorem i' < k'  ===  i' + k' < j' + k';
MonotonicityOfMultiplication: theorem 0 < k'  ==>  (i' < k'  ===  i'*k' = j'*k');
Trichotomy: theorem ( (i' < k') & ~(k' < i') & k' != i')
                  | (~(i' < k') &  (k' < i') & k' != i')
                  | (~(i' < k') & ~(k' < i') & k'  = i');
// An alternative statement of Trichotomy
  private theorem (i' < k' | i' > k' | i' = k')
                & ~(i' < k' & i' > k')
                & ~(i' < k' & i' = k')
                & ~(i' > k' & i' = k');
Antisymmetry: theorem i' <= j' & j' <= i'  ==>  i' = j';
Reflexivity: theorem n' <= n';
private theorem i' = j'   ===   (k' <= i'  ===  k' <= j');

/**************** WORKING HERE ***********************/



private static boolean sameSignLax(I a, I b);
  means return = (a>=0) ? b>=0 : b<=0;

/** Integer division with a remainder. We provide for computing the quotient and remainder in a
   single operation.
   @see div()
   @see mod() */
static public Int intDiv(Int dividend', Int divisor',
                                 Int 'quotient, Int 'remainder);
  means dividend div divisor = quotient
      & dividend  %  divisor = remainder
  ;

/** Integer division, which leaves a remainder. We map the div(n,d) method to the <code>div</code>
   operator, saving the operator / for division that does not leave a remainder, as in rational
   number division.
   <p> Usage: n div d or div(n,d)
   @see Definition of integer division in Java Language Specification, Topic 15.17.2 */
public static Int div(Int n', Int d') phrase <n' div d'>;
  given d' != 0;
  means forsome Int remainder
      ( n' = return' * d' + remainder'
      &   (sameSignLax(n',d') ==> 0 <= remainder < d')
      & ! (sameSignLax(n',d') ==> 0 >= remainder > d')
      );

/** The remainder of integer division, We map the mod() method to the operator <code> % </code>.
   <p> Usage: a % b or mod(a,b)
   @see Definition of the remainder, % (Java Language Specification, Topic 15.17.3)
   @see intdiv */
public static Int mod(Int a, Int b) phrase <a % b>;
  given b != 0;
  means forsome Int quotient
      ( a = quotient * b + return
      &   (sameSignLax(a,b) ==> 0 <= return < b)
      & ! (sameSignLax(a,b) ==> 0 >= return > b)
  ;

theorem  j!=0  ==>  (i div j)*j + (i % j) = i;

/** Do the parameters have the same sign? Returns true if either is zero. */
// ********************
// *** Constructors ***
// ********************
public Int() {
  // if there is a reasonable default for every field, you can create a default constructor
}

public Int(Int a) {
  this.a = new TYPEAAA(a); // copy constructor should create a deep copy
}

// ******************************
// *** Consistency components ***
// ******************************
public int hashCode() {
  // Consistent with equals: two "equals" objects should have same hashCode result.
  return hashCode(a);
}

public Object clone() { // shallow copy
  return new Name(a);
}

public Name deepCopy {
  return new Name(new Int(a));
}

public String toString() {
  return (a.toString);
}

} // end class IntegerDomain