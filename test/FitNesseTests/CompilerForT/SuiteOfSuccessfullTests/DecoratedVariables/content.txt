!4 Check the syntax and generated code for pre- and post-decorated names
!fixture tlang.StartT
!| tlang.StartT |

----
The T Language attempts to direct the programmer's attention to what can be said about the state of the data as each step of the T program is executed. Java is used as the starting place for the T Language's syntax and semantics, and the T Language diverges from Java only when this attention to state requires it. There is a sense in which Java never explicitly represents state, so our first order of business is to add to the T Language a way for the state contained in the variables to be explicitly represented.

!3 Use of decorated names to represent the values held by variables
The state of the data is held as values in variables, and the value of these variables is changed within methods. Therefore to make statements about state is primarily to make statements about how values are constructed using variables. We explicitly show the relationship between the two separate ideas of value and variable by constructing value names from the name of the variable that holds, or once held, the value. Value names are variable names decorated with an apostrophe before or after to indicate  the value of the variable before or after the execution of a method. Later we will also use names for intermediate values during the execution of a method, which are constructed by appending an apostrophe and a distinguishing name to the variable name, but we don't have need for those value names on this page.  Most formal methods researchers and language designers work with values before and after the  execution of a ''statement'', so take note that our concern is the ''method'' and that value names keep the same meaning throughout the method. Others also use a naked variable name to refer to the value of the variable at that point in the program, but we ''always'' decorate the variable name when we refer to the value that it holds.

Within a method, the T statements '''given''', '''lemma''', '''conjecture''' and '''means''' record  our expectations  and requirements about the state of the data. Our first example will demonstrate the conjecture and the means statements. The only T Language operational statement that we introduce is the java block, which allows the programmer to drop into the Java language when a feature is needed that is not available in the T Language. Because Java does not have a fully  formal definition, we can only conjecture what the Java code will do, although in this case we'll  use a very high  confidence of .99 out of 1 because the Java is very simple. Later we will show how  the means requirements  are automatically proven correct.

| start new T program |
| program code lines |
| {{{class OrderedPair {                                                 }}} |
| {{{  private int first;                                                }}} |
| {{{  private int second;                                               }}} |
| {{{                                                                    }}} |
| {{{  void swap() {                                                     }}} |
| {{{    int temp;                                                       }}} |
| {{{    java (temp')   {temp  =  first;}                                }}} |
| {{{    conjecture .99 (temp' = 'first );                               }}} |
| {{{                                                                    }}} |
| {{{    java (first')  {first  =  second;}                       }}} |
| {{{    conjecture .99 (first' = 'second );                      }}} |
| {{{                                                                    }}} |
| {{{    means (temp' = 'first && first' = 'second);                     }}} |
| {{{                                                                    }}} |
| {{{    java (second') {second  =  temp;}                       }}} |
| {{{    conjecture .99 (second' =  temp');                      }}} |
| {{{                                                                    }}} |
| {{{    means (temp' = 'first && first' = 'second && second' =  temp'); }}} |
| {{{    means                   (first' = 'second && second' = 'first); }}} |
| {{{  }                                                                 }}} |
| {{{                                                                    }}} |
| {{{} // end class OrderedPair                                          }}} |

Some notes about the above code: The declaration of a variable is left undecorated unless it is initialized with a value. We have aligned the variable and value names to emphasize the differences in coding Java operational statements and T Language state statements. Unlike the lemma and means statements, conjectures are ''not'' automatically proven correct from previous statements; however, they are checked at runtime, like Java's assert statement. The means statement summarizes all the information that will be needed for proofs of following statements; that is, automated proofs only look backward to the latest means statement to collect information to use in a proof.

| check | result of parse | OK |
| check | semantic errors | OK |
| check | java generation | OK |
| check | proof           | OK |
| check | java compile    | OK |

Next, we trivially simplify the above program by leaving out the unneeded means statements since the conjecture statements form a sufficient proof outline. Note that the automated proof of the means statement ANDs together the method's conjecture statements to form the premise for the proof of the means statement. Technically, the meaning of the method is this simple conjunction of its statements.

| start new T program |
| program code lines |
| {{{class OrderedPair {                                                 }}} |
| {{{  private int first;                                                }}} |
| {{{  private int second;                                               }}} |
| {{{                                                                    }}} |
| {{{  void swap() {                                                     }}} |
| {{{    int 'temp;                                                      }}} |
| {{{    java (temp') {temp = first;}                            }}} |
| {{{    conjecture .99 (temp' = 'first);                                }}} |
| {{{                                                                    }}} |
| {{{    java (first') {first = second;}                         }}} |
| {{{    conjecture .99 (first' = 'second);                              }}} |
| {{{                                                                    }}} |
| {{{    java (second') {second = temp;}                         }}} |
| {{{    conjecture .99 (second' =  temp');                              }}} |
| {{{                                                                    }}} |
| {{{    means                   (first' = 'second && second' = 'first); }}} |
| {{{  }                                                                 }}} |
| {{{                                                                    }}} |
| {{{} // end class OrderedPair                                          }}} |

| check | result of parse | OK |
| check | semantic errors | OK |
| check | java generation | OK |
| check | java compile | OK |

!4 Translate by commenting out non-java
To translate the T code above, the T logic statements and the java keyword are commented out, leaving java code. Note that the javalangauge code fragments are each treated as a Java block.

| Generated Java lines |
| code lines |
| {{{class OrderedPair {                                                       }}} |
| {{{  private int first;                                                      }}} |
| {{{  private int second;                                                     }}} |
| {{{                                                                          }}} |
| {{{  void swap() {                                                           }}} |
| {{{    int /*'*/temp;                                                        }}} |
| {{{    /* java */ /* (temp') */ {temp = first;}                            }}} |
| {{{    /* conjecture .999 (temp' = 'first); */                               }}} |
| {{{                                                                          }}} |
| {{{    /* java */ /* (first') */ {first = second;}                                  }}} |
| {{{    /* conjecture .999 (first' = 'second); */                             }}} |
| {{{                                                                          }}} |
| {{{    /* lemma (temp' = 'first && first' = 'second); */                     }}} |
| {{{                                                                          }}} |
| {{{    /* java */ /* (second') */ {second = temp;}                   }}} |
| {{{    /* conjecture .999 (second' =  temp'); */                             }}} |
| {{{                                                                          }}} |
| {{{    /* lemma (temp' = 'first && first' = 'second && second' =  temp'); */ }}} |
| {{{                                                                          }}} |
| {{{    /* means                   (first' = 'second && second' = 'first); */ }}} |
| {{{  }                                                                       }}} |
| {{{                                                                          }}} |
| {{{  // The constructor for the object                                       }}} |
| {{{  OrderedPair(int item_1/*'*/, int item_2/*'*/) {                         }}} |
| {{{    /* java */ {                                                  }}} |
| {{{      first = item_1;                                                     }}} |
| {{{      second = item_2;                                                    }}} |
| {{{    }                                                                     }}} |
| {{{    /* conjecture .999 (first' = item_1' && second' =  item_2'); */       }}} |
| {{{  }                                                                       }}} |
| {{{} // end class OrderedPair                                                }}} |

----
!4 Use of decorated names in executable code
Next we simplify the above code for the swap method by coding it directly in T. Only decorated value names are used in T methods; no variable names are allowed.

In the constructor, note that the parameters are values with a post-decoration, indicating that they are final values and may not be changed. The code of the constructor defines the integer components of an !-OrderedPair-! as post-decorated values because they will not be changed within the constructor.

The swap method does, however, change the object's component values. The value-definition statements ('assignment' statements) are simple enough that their meaning in T is directly communicated to both the human and the prover. Because their meanings are defined in the T language, we don't need to make conjectures. And note that the effect of the definition statements is cummulative in the sense that no statement has to be withdrawn. Thus the lemas above are also superfluous.

A later test page will show how the means statement is derived from the T language statements in swap().

| start new T program |
| program code lines |
| {{{class OrderedPair {                                                 }}} |
| {{{  private int first;                                                }}} |
| {{{  private int second;                                               }}} |
| {{{                                                                    }}} |
| {{{  // The constructor for the object                                 }}} |
| {{{  OrderedPair(int item_1', int item_2') {                           }}} |
| {{{    first' = item_1';                                               }}} |
| {{{    second' = item_2';                                              }}} |
| {{{  }                                                                 }}} |
| {{{                                                                    }}} |
| {{{  void swap() {                                                     }}} |
| {{{    int temp' = 'first;                                             }}} |
| {{{    first' = 'second;                                               }}} |
| {{{    second' = temp';                                                }}} |
| {{{    means  (first' = 'second && second' = 'first);                  }}} |
| {{{  }                                                                 }}} |
| {{{} // end class OrderedPair                                          }}} |

| check | result of parse | OK |
| check | semantic errors | OK |
| check | java generation | OK |

!4 Simple translation of values to variables.
| Generated Java lines |
| code lines |
| {{{class OrderedPair {                                         }}} |
| {{{  private int first;                                        }}} |
| {{{  private int second;                                       }}} |
| {{{                                                            }}} |
| {{{  // The constructor for the object                         }}} |
| {{{  OrderedPair(int item_1/*'*/, int item_2/*'*/) {           }}} |
| {{{    first/*'*/ = item_1/*'*/;                               }}} |
| {{{    second/*'*/ = item_2/*'*/;                              }}} |
| {{{  }                                                         }}} |
| {{{                                                            }}} |
| {{{  void swap() {                                             }}} |
| {{{    int temp/*'*/ = /*'*/first;                             }}} |
| {{{    first/*'*/ = /*'*/second;                               }}} |
| {{{    second/*'*/ = temp/*'*/;                                }}} |
| {{{    /* means  (first' = 'second && second' = 'first); */    }}} |
| {{{  }                                                         }}} |
| {{{} // end class OrderedPair                                  }}} |

----
