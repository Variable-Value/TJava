!3 Preserve Decorated Values when they are needed later in the method or later in a calling method

When a value in an object data state component (variable) is overwritten, that value is no longer available, normally. In order to allow the overwritten value to be referred to after the new value is computed, the original value must be preserved. Only a shallow copy of the original value is needed, but care must be taken to make shallow copies of all its component descendent tree, recursively, at any point where a component descendent is passed to methods where its state can be updated. Note that the component receiving a message is implicitly a parameter, and if any of the components of the one receiving the message are updated, then the message receiver needs to be preserved, as well as its updated component. Note also that a pre- or post-increment is like a method that updates its parameter and must use the pre-post-form of decoration.

The copying of state is split between the calling and called routines. In the calling routine, we know whether the pre-state will be reused and whether the called routine has a signature that threatens the pre-state; therefore, the pre-state is copied in the calling routine, but it is only a shallow copy, leaving its components shared with the post-state copy. In the called routine, we know which components of the post-state have been modified, therefore we copy the pre-state of those components before modification. The pre-state of the component is left connected to the pre-state and it's aliases, while the changed component is connected to the post-state. 

An alternative is to mark an object as to whether the changed state is ever needed, either within the object or in an accompanying boolean that is passed with it and allow the return of both states if it is changed. Perhaps every call could be with a pair, then the post-form in the pair could be copied and changed with impunity, but only when needed. Note that Java will not allow the pair to change, but it's coponents may change, therefore the pre-form will not need to be copied unless the called routine modifies the parameter. There will need to be a special parameter for the pre-form of the this object that adds an extra level of indirection allowing the this to be copied into it.

In either case, note that any aliases of the object will automatically receive one of the states unless they are dealt with in the calling routine - this would most naturally be the changed state. The primary such aliased objects will be those that are components of other objects. Therefore, if an object's constraints involve an object that is not "owned" by the containing object, there must be a callback mechanism in the containing object so that it knows which objects contain it and can signal them with its state changes. We could either force the call back to be present if a constraint referred to the  state of an object or we could simply leave the alias pointing to the pre-state unless there was a call-back mechanism in place.

!|t_translator.StartT|
----
!***** !3 Use of decorated names after write of their post-form
|start new T program|
|program code lines|
|{{{class OrderedPair {                                                 }}}|
|{{{  private int first;                                                }}}|
|{{{  private int second;                                               }}}|
|{{{                                                                    }}}|
|{{{  // The constructor for the object                                 }}}|
|{{{  OrderedPair(int item_1', int item_2') {                           }}}|
|{{{    first' = item_1';                                               }}}|
|{{{    second' = item_2';                                              }}}|
|{{{  }                                                                 }}}|
|{{{                                                                    }}}|
|{{{  void swap() {                                                     }}}|
|{{{    first' = 'second;                                               }}}|
|{{{    second' = 'first;                                               }}}|
|{{{  }                                                                 }}}|
|{{{} // end class OrderedPair                                          }}}|

|check|result of parse|OK|

!3 Saving the pre-decorated form when necessary.
We can translate to a simple form of Java, because the translator must check for the validity of the
T code anyway.

|Java output|
|code lines|
|{{{class OrderedPair {                                         }}}|
|{{{  private int first;                                        }}}|
|{{{  private int second;                                       }}}|
|{{{                                                            }}}|
|{{{  // The constructor for the object                         }}}|
|{{{  OrderedPair(int item_1/*post*/, int item_2/*post*/) {     }}}|
|{{{    first/*post*/ = item_1/*post*/;                         }}}|
|{{{    second/*post*/ = item_2/*post*/;                        }}}|
|{{{  }                                                         }}}|
|{{{                                                            }}}|
|{{{  void swap(bool keepThis) {                                }}}|
|{{{    if (keepThis) {                                         }}}|
|{{{      final OrderedPair t$pre$t_this = clone(this);         }}}|
|{{{    }                                                       }}}|
|{{{    final int t$pre$t_first = /*pre*/first;                 }}}|
|{{{    first/*post*/ = /*pre*/second;                          }}}|
|{{{    second/*post*/ = t$pre$t_first;                         }}}|
|{{{  }                                                         }}}|
|{{{} // end class OrderedPair                                  }}}|
----
**********!