/**
 * Utility methods for common use in the TestXXX classes
 */
package t_translator;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import org.antlr.runtime.ANTLRStringStream;
import org.antlr.runtime.RuleReturnScope;
import org.antlr.runtime.TokenRewriteStream;
import org.antlr.runtime.tree.BaseTree;
import org.antlr.runtime.tree.CommonTreeNodeStream;
import org.antlr.runtime.tree.Tree;
import org.antlr.runtime.tree.TreeRuleReturnScope;
import t_translator.T2TreeParser.Lang;
import t_translator.T2TreeParser.LangScope_scope;
import t_translator.T2TreeParser.ParserRuleReturnScope;

/**
 * @author cowang
 *
 */
public class 
TTester {

protected ANTLRStringStream input;
protected TokenRewriteStream tokenStream;
protected T2TreeLexer  lexer;
protected T2TreeParser parser;
protected ParserRuleReturnScope parseResults;
protected TreeRuleReturnScope logicResults;
protected ErrCheck checker;
protected TTree2Java javaMaker;
protected TTree2LogicAST logicASTMaker;
protected CommonTreeNodeStream treeStream;
protected Tree tree;
protected Tree logicTree;

// LEXER and PARSER methods *******************************

protected T2TreeLexer
prepareLexer(String[] lines) {
  String text = arrayToLines(lines);
  input = new ANTLRStringStream(text);
  return new T2TreeLexer(input);
}

protected T2TreeParser
prepare(String... text) {
  return prepare(Lang.tLanguage, text);
}

protected T2TreeParser
prepare(Lang lang, String... text) {
  lexer = prepareLexer(text);
  tokenStream = new TokenRewriteStream(lexer);
  parser = new T2TreeParser(tokenStream);
  ((LangScope_scope)parser.LangScope_stack.peek()).language = lang;
  return parser;
}

protected void
checkLexParse(T2TreeParser.ParserRuleReturnScope returned) {
  if (lexer.lexErrors().length() != 0) {
    fail("LEXER ERROR: "+lexer.lexErrors().toString());
  }
  if (parser.errors().length() != 0) {
    fail("PARSE ERROR: "+parser.errors().toString());
  }
  if (returned == null) {
    fail("NO TREE RETURNED FROM PARSE");
  }
}

protected ErrCheck
buildSemanticCheckerIfOk(T2TreeParser.ParserRuleReturnScope returned) {
  checkLexParse(returned);
  treeStream = buildTreeStream(returned);
  checker = new ErrCheck(treeStream);
  Lang ruleLanguage = ((T2TreeParser.LangScope_scope)parser.LangScope_stack.peek()).language;
  ((ErrCheck.LangScope_scope)checker.LangScope_stack.peek()).language = ruleLanguage;
  return checker;
}

protected CommonTreeNodeStream
buildTreeStream(T2TreeParser.ParserRuleReturnScope returned) {
  if (returned == null) {
    fail("NO TREE RETURNED");
  }
  tree = getTree(returned);
  treeStream = new CommonTreeNodeStream(tree);
  treeStream.setTokenStream(tokenStream);
  return treeStream;
}

protected BaseTree
getBaseTree(RuleReturnScope s) {
  return (BaseTree)s.getTree();
}

protected Tree
getTree(T2TreeParser.ParserRuleReturnScope returned) {
  tree = getBaseTree(returned);
  return tree;
}

protected TTree2Java
buildJavaTranslatorIfOk(T2TreeParser.ParserRuleReturnScope returned) {
  checkSemantics();
//  treeStream = buildTreeStream(returned);
  treeStream.reset();
  javaMaker = new TTree2Java(treeStream);
  Lang ruleLanguage = ((T2TreeParser.LangScope_scope)parser.LangScope_stack.peek()).language;
  ((TTree2Java.LangScope_scope)javaMaker.LangScope_stack.peek()).language = ruleLanguage;
  return javaMaker;
}

protected void
checkSemantics() {
  checkSemantics("");
}

protected void
checkSemantics(String msg) {
  if (checker.errors().length() != 0) {
    final String tempMsg = (msg=="")?msg: msg+"  " ;
    fail(tempMsg + "SEMANTIC ERROR: "+checker.errors().toString());
  }
}

protected void
checkJavaOK(String msg) {
  if (javaMaker.errors().length()>=0) {
    assertEquals(msg, "No errors expected.", javaMaker.errors().toString());
  }
}

protected void
checkJavaOK(TreeRuleReturnScope returned) {
  checkJavaOK("", returned);
}


protected void
checkJavaOK(String expected, TreeRuleReturnScope returned) {
 if (javaMaker.errors().length()==0) {   // no errors found
   if (expected.length()>0) {
     if (returned == null) {
       assertEquals(expected, "null returned from rule");
     } else {
       // assertTrue(msg, expected.equals(returned.toString()));
       assertEquals(expected, returned.toString());
     }
   }
 } else { // errors found
   assertEquals("No errors expected.", javaMaker.errors().toString());
 }
}

protected void
checkJavaFAIL(String msg) {
  final TreeRuleReturnScope returned = null;
  checkJavaFAIL(msg, returned);
}

protected void
checkJavaFAIL(String msg, TreeRuleReturnScope returned) {
  final String[] expected = new String[] {};
  checkJavaFAIL(msg, expected, returned);
}

protected void
checkJavaFAIL(String msg, String[] expected, TreeRuleReturnScope returned) {
  if (javaMaker.errors().length()!=0) {   // errors found
    for (int item=0; item < expected.length; item++) {
      assertTrue(msg, javaMaker.errors().toString().contains(expected[item]));
    }
  } else {      // expected error was not present
    if (returned==null) {
      assertEquals(msg, "FAIL", "null returned from rule");
    } else {
      assertEquals(msg, "FAIL", "OK");
    }
  }
}

protected TTree2LogicAST
buildLogicExtractorIfOK(T2TreeParser.ParserRuleReturnScope returned) {
  checkSemantics();
  //treeStream = buildTreeStream(returned);
  treeStream.reset();
  tree = getTree(returned);
  logicASTMaker = new TTree2LogicAST(treeStream);
  // Lang ruleLanguage = ((T2TreeParser.LangScope_scope)parser.LangScope_stack.peek()).language;
  // ((TTree2Java.LangScope_scope)logicASTMaker.LangScope_stack.peek()).language = ruleLanguage;
  return logicASTMaker;
}


protected void
checkParserASTOK(String expected, T2TreeParser.ParserRuleReturnScope returned) {
  checkParserASTOK("", expected, returned);
}

protected void
checkParserASTOK( String                             msg
                , String                             expected
                , T2TreeParser.ParserRuleReturnScope returned
                ) {
  if (lexer.lexErrors().length() + parser.errors().length() == 0) {
    if (returned == null) {
      fail(msg+"  ERRORS: Parser returned NULL instead of Tree/n");
    } else {
      if (expected != ""){
        assertEquals(msg, expected, getBaseTree(returned).toStringTree());
      }
    }
  } else {
    fail(msg+" ERRORS: "+lexer.lexErrors().append(parser.errors()).toString());
  }
}

protected void
assertLogicASTOK( String     msg
                , String     expected
                , Tree       returnTree
                ) {
  if (logicASTMaker.errors().length() == 0) {
    if (returnTree == null) {
      fail(msg+"  ERRORS: TTree2LogicAST returned NULL instead of Tree/n");
    } else if (expected != "") {
        assertEquals(msg, expected, returnTree.toStringTree());
    }
  } else {
    fail(msg+" ERRORS: "+logicASTMaker.errors().toString());
  }
}

protected void
assertLogicTextOK( String              msg
                 , String              expected
                 , TreeRuleReturnScope returned
                 ) {
  if (logicASTMaker.errors().length() == 0) {
    if (expected != "") {
      if (returned != null) {
        assertEquals(msg, expected, returned.toString());  // getBaseTree(returned).toStringTree());
      } else {
        fail(msg+" ERRORS: RETURNED value is null");
      }
    }
  } else {
    fail(msg+" ERRORS: "+logicASTMaker.errors().toString());
  }
}


protected String
shapedText(String... lines) {
  StringBuilder result = new StringBuilder();
  for (int i=0; i<lines.length; i++) {
    if (lines[i].equals(" ") ) {result.append(" ");}
    else                       {result.append(lines[i].trim());}
  }
  return result.toString();
}

protected String
shapedAST(String... lines) {
  StringBuilder result = new StringBuilder();
  for (int i=0; i<lines.length; i++) {
    if (lines[i].equals(" ") ) {result.append(" ");}
    else                       {result.append(lines[i].trim());}
  }
  return result.toString();
}

protected String
indentedAST(String... lines) {
  StringBuilder result = new StringBuilder();
//  for (int lineNum=0; lineNum<lines.length; lineNum++) {
//    result.append(lines[lineNum].trim());
//    if (lines[lineNum].endsWith(" ")) {
//      result.append(" ");
//    }
//  }
  for (String line : lines) {
    result.append(line.trim());
    if (line.endsWith(" ")) {
      result.append(" ");
    }
  }
  return result.toString();
}

//protected String
//indentedAST(String... lines) {
//  StringBuilder result = new StringBuilder();
//  for (int lineNum=0; lineNum<lines.length; lineNum++) {
//    int firstNonspaceFound = 0; // so far
//    while (firstNonspaceFound < lines[lineNum].length() && lines[lineNum].charAt(firstNonspaceFound)==' ') {
//      firstNonspaceFound++;
//    }
//    result.append(lines[lineNum].substring(firstNonspaceFound));
//  }
//  return result.toString();
//}

protected String 
arrayToLines(String[] lines){
  StringBuilder result = new StringBuilder();
  for (String line : lines){
    result.append(line+"\r\n");
  }
  return result.substring(0, result.length()-2);   //.toString();
}

protected String 
text(String... lines){
  return arrayToLines(lines);
}

protected String 
expected(String... lines){
  return arrayToLines(lines);
}

// FOR CHECKING CONTENT OF ERROR MESSAGES (See TestErrCheck.java)

String[][] inExpected(String[]... required) {
  return required;
}

String[] line(String... components){
  return components;
}



}
