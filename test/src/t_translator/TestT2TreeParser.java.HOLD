/**
 *
 */
package t_translator;

import static org.junit.Assert.assertEquals;
import static t_translator.T2TreeParser.SAVING;
import org.antlr.runtime.CommonToken;
import org.antlr.runtime.RecognitionException;
import org.antlr.runtime.tree.CommonTree;
import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Ignore;
import org.junit.Test;
import t_translator.T2TreeParser.ClassScope_scope;
import t_translator.T2TreeParser.Lang;
import t_translator.T2TreeParser.ParserRuleReturnScope;


/**
 * @author cowang
 *
 */
public class TestT2TreeParser extends TTester {

/* ***
checkResults() ***/ public void
checkResults(String terminationStatus) {
  checkResults("", terminationStatus, null, "");
}

public void
checkResults(String msg, String terminationStatus) {
  checkResults(msg, terminationStatus, null, "");
}

public void
checkResults(String msg, String terminationStatus, String expected) {
  checkResults(msg, terminationStatus, null, expected);
}

public void
checkResults(String terminationStatus, T2TreeParser.ParserRuleReturnScope returned) {
  checkResults("", terminationStatus, returned, "");
}

public void
checkResults(String msg, String expected, T2TreeParser.ParserRuleReturnScope returned) {
  checkResults(msg, expected, returned, "");
}

public void
checkResults(String terminationStatus, T2TreeParser.ParserRuleReturnScope returned, String expected) {
  checkResults("", terminationStatus, returned, expected);
}

public void
checkResults( String                              msg
              , String                             terminationStatus
              , T2TreeParser.ParserRuleReturnScope returned
              , String                             expected
              ) {
  if (lexer.lexErrors().length() + parser.errors().length() == 0) {
    assertEquals(msg, terminationStatus.toUpperCase(), "OK");
    if (expected != "" && returned != null){
      assertEquals(msg, expected, returned.getBaseTree().toStringTree());
    }
  } else {
    assertEquals(msg, terminationStatus.toUpperCase(), "FAIL");
    if (expected != ""){
      assertEquals(msg, expected, lexer.lexErrors().append(parser.errors()).toString());
    }
  }
}

@Override
public String
shapedAST(String... lines) {
  StringBuilder result = new StringBuilder(lines[0]);
  for (int i=1; i<lines.length; i++) {
    result.append(lines[i]);
  }
  return result.toString(); // trim to get rid of final space from last append()
}

@Override
public String
expected(String... err){
  StringBuilder result = new StringBuilder();
  for (String error : err){
    result.append(error+"\n");
  }
  return result.toString();
}



/**
 * @throws java.lang.Exception
 */
@BeforeClass
public static void setUpBeforeClass() throws Exception {
}

/**
 * @throws java.lang.Exception
 */
@AfterClass
public static void tearDownAfterClass() throws Exception {
}

/**
 * @throws java.lang.Exception
 */
@Before
public void setUp() throws Exception {
}

/**
 * @throws java.lang.Exception
 */
@After
public void tearDown() throws Exception {
}

@Test
@Ignore
public final void testCompilationUnit() {
//  fail("Not yet implemented");
}

@Test
@Ignore
public final void testPackageDeclaration() {
//  fail("Not yet implemented");
}

@Test
@Ignore
public final void testImportDeclaration() {
//  fail("Not yet implemented");
}

@Test
@Ignore
public final void testMemberDecl2() {
//  fail("Not yet implemented");
}

@Test
@Ignore
public final void testMethodDeclaration() {
//  fail("Not yet implemented");
}

@Test
@Ignore
public final void testType() {
//  fail("Not yet implemented");
}

@Test
@Ignore
public final void testFormalParameters() {
//  fail("Not yet implemented");
}

@Test
@Ignore
public final void testNormalParameterDecl() {
//  fail("Not yet implemented");
}

@Test
@Ignore
public final void testQualifiedName() {
//  fail("Not yet implemented");
}

@Test
@Ignore
public final void testLanguageBlock() {
//  fail("Not yet implemented");
}

@Test
@Ignore
public final void testBlockStatement() {
//  fail("Not yet implemented");
}

@Test
@Ignore
public final void testStatement() {
//  fail("Not yet implemented");
}


@Test
public final void
testSimpleAST() throws RecognitionException {
  prepare( "class OrderedPair {                                                 "
               , "  private int first;                                                "
               , "  private int second;                                               "
               , "                                                                    "
               , "  // The constructor for the object                                 "
               , "  OrderedPair(int item_1', int item_2') {                           "
               , "    javalanguage {                                                  "
               , "      first = item_1;                                               "
               , "      second = item_2;                                              "
               , "    }                                                               "
               , "    conjecture .999 (first' = item_1' && second' =  item_2');       "
               , "  }                                                                 "
               , "} // end class OrderedPair                                          "
               );
  ParserRuleReturnScope parserReturn = parser.normalClassDeclaration();
  checkResults("OK", parserReturn
              ,shapedAST("(class OrderedPair "                                                   .trim() + " "
                        ,"  (SAVING 'first 'second) "                                            .trim() + " "
                        ,"  { private int first ;"                                               .trim() + " "
                        ,"    private int second ;"                                              .trim() + " "
                        ,"    OrderedPair ( int item_1' , int item_2' ) {"                       .trim() + " "
                        ,"       (javalanguage javalanguage"                                     .trim() + " "
                        ,"         ({ first = item_1 ;"                                          .trim() + " "
                        ,"              second = item_2 ;"                                       .trim() + " "
                        ,"          }"                                                           .trim()
                        ,"         )"                                                            .trim() + " "
                        ,"         (conjecture .999 (LOGIC first' = item_1' && second' = item_2'))" .trim()
                        ,"       ) "                                                             .trim() + " "
                        ,"    }"                                                                 .trim() + " "
                        ,"  }"                                                                   .trim()
                        ,")"                                                                     .trim()
                        )
              );
}

@Test
public final void
complicatedConstructorShouldBeOK() throws RecognitionException {
  prepare
    ( "class OrderedPair {                                                 "
    , "  private int first;                                                "
    , "  private int second;                                               "
    , "                                                                    "
    , "  // The constructor for the object                                 "
    , "  OrderedPair(int item_1', int item_2') {                           "
    , "    javalanguage {                                                  "
    , "      first = item_1;                                               "
    , "      second = item_2;                                              "
    , "    }                                                               "
    , "    conjecture .999 (first' = item_1' && second' =  item_2');       "
    , "  }                                                                 "
    , "} // end class OrderedPair                                          "
    );
  ParserRuleReturnScope parserReturn = parser.normalClassDeclaration();
  checkResults("OK", parserReturn);
}

@Test
public final void
fieldDeclaration1() throws RecognitionException {
  checkResults("Java declaration of multiple fields.", "OK", prepare(Lang.javaLanguage, "int x,y;").fieldDeclaration());

  parser = prepare(Lang.tLanguage   , "int x,y;");
  ((ClassScope_scope)parser.ClassScope_stack.peek()).classVarTree = new CommonTree(new CommonToken(SAVING,"SAVING"));
  checkResults("T multiple class component fields."  , "OK", parser.fieldDeclaration());
}

@Test
@Ignore
public final void testParenthesizedLogic() {
//  fail("Not yet implemented");
}

@Test
@Ignore
public final void testExpression() {
//  fail("Not yet implemented");
}

@Test
public final void javatypeIsIDNotReserved() throws RecognitionException {
  parser = prepare("javatype");
  // insert optional initialization code here
  checkResults("OK",parser.primary(),"javatype");

  checkResults("Simple Identifier followed by whitespace.", "OK", prepare("javatype ").primary(), "javatype");

  prepare("name'decorated").primary();
  checkResults("Simple Identifier followed by whitespace.", "OK"
              , prepare(Lang.tLanguage, "javatype ").primary()
              , "javatype"
              );
}

}

